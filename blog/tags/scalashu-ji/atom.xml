<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Scala书籍 | Scala教程]]></title>
  <link href="http://scalajiaocheng.github.io/blog/tags/scalashu-ji/atom.xml" rel="self"/>
  <link href="http://scalajiaocheng.github.io/"/>
  <updated>2016-01-06T00:40:12+08:00</updated>
  <id>http://scalajiaocheng.github.io/</id>
  <author>
    <name><![CDATA[Scala教程]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Learning Scala CHAPTER 2 Working with Data: Literals, Values,Variables, and Types]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-2-working-with-data-literals-values-variables-and-types/"/>
    <updated>2015-12-29T23:25:28+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-2-working-with-data-literals-values-variables-and-types</id>
    <content type="html"><![CDATA[<p>In this chapter we will cover the core data and variable types in Scala. Let’s start with the definitions of the terms <code>literal</code>, <code>value</code>, <code>variable</code>, and <code>type</code>:</p>

<ul>
  <li>A literal (or literal data) is data that appears directly in the source code, like the number <code>5</code>, the character <code>A</code>, and the text “<code>Hello, World.</code>”</li>
  <li>A value is an immutable, typed storage unit. A value can be assigned data when it is defined, but can never be reassigned.</li>
  <li>A variable is a mutable, typed storage unit. A variable can be assigned data when it is defined and can also be reassigned data at any time.</li>
  <li>A type is the kind of data you are working with, a definition or classification of data.</li>
</ul>

<p>All data in Scala corresponds to a specific type, and all Scala types are defined as classes with methods that operate on the data.       <br />
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#values" id="markdown-toc-values">Values</a>    <ul>
      <li><a href="#syntax-defining-a-value" id="markdown-toc-syntax-defining-a-value">Syntax: Defining a Value</a></li>
    </ul>
  </li>
  <li><a href="#variables" id="markdown-toc-variables">Variables</a>    <ul>
      <li><a href="#syntax-defining-a-variable" id="markdown-toc-syntax-defining-a-variable">Syntax: Defining a Variable</a></li>
    </ul>
  </li>
  <li><a href="#naming" id="markdown-toc-naming">Naming</a></li>
  <li><a href="#types" id="markdown-toc-types">Types</a>    <ul>
      <li><a href="#numeric-data-types" id="markdown-toc-numeric-data-types">Numeric Data Types</a></li>
      <li><a href="#literal-characters-are-case-insensitive" id="markdown-toc-literal-characters-are-case-insensitive">Literal Characters Are Case-Insensitive</a></li>
    </ul>
  </li>
  <li><a href="#strings" id="markdown-toc-strings">Strings</a>    <ul>
      <li><a href="#string-interpolation" id="markdown-toc-string-interpolation">String interpolation</a></li>
    </ul>
  </li>
  <li><a href="#regular-expressions" id="markdown-toc-regular-expressions">Regular expressions</a>    <ul>
      <li><a href="#table-2-3-regular-expression-operations" id="markdown-toc-table-2-3-regular-expression-operations">Table 2-3. Regular expression operations</a>        <ul>
          <li><a href="#syntax-capturing-values-with-regular-expressions" id="markdown-toc-syntax-capturing-values-with-regular-expressions">Syntax: Capturing Values with Regular Expressions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#an-overview-of-scala-types" id="markdown-toc-an-overview-of-scala-types">An Overview of Scala Types</a>    <ul>
      <li><a href="#table-2-4-core-nonnumeric-types" id="markdown-toc-table-2-4-core-nonnumeric-types">Table 2-4. Core nonnumeric types</a>        <ul>
          <li><a href="#what-is-the-difference-between--and--" id="markdown-toc-what-is-the-difference-between--and--">What is the Difference Between &amp; and &amp;&amp; ?</a></li>
        </ul>
      </li>
      <li><a href="#type-operations" id="markdown-toc-type-operations">Type operations</a>        <ul>
          <li><a href="#table-2-5-common-type-operations" id="markdown-toc-table-2-5-common-type-operations">Table 2-5. Common type operations</a>            <ul>
              <li><a href="#avoid-asinstanceof" id="markdown-toc-avoid-asinstanceof">Avoid asInstanceOf</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#tuples" id="markdown-toc-tuples">Tuples</a>        <ul>
          <li><a href="#syntax-create-a-tuple" id="markdown-toc-syntax-create-a-tuple">Syntax: Create a Tuple</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<p>The data stored in values and variables in Scala will get automatically deallocated by the Java Virtual Machine’s garbage collection when they are no longer used. There is no ability, or need, to deallocate them manually.</p>

<p>Let’s try exercising these terms by working with data in the Scala REPL. Scala values are defined with the syntax <code>val &lt;name&gt;: &lt;type&gt; = &lt;literal&gt;</code>, so we will create a value with the name <code>x</code>, type <code>Int</code>(short for “<code>integer</code>”), and assigned it the literal number <code>5</code>:</p>

<pre><code>scala&gt; val x: Int = 5
x: Int = 5
</code></pre>

<p>What happened here? The REPL (again, a Read-Evaluate-Print-Loop shell) read the value definition, evaluated it, and reprinted it as a confirmation. The new value, named <code>x</code>, is now defined and available to use. So let’s use it:</p>

<pre><code>scala&gt; x
res3: Int = 5

scala&gt; x * 2
res4: Int = 10

scala&gt; x * 2
res5: Int = 10

scala&gt; x / 5
res6: Int = 1
</code></pre>

<p>Each of these three input lines are valid Scala syntax and return an integer value. In each case, because a value is returned, the REPL repeats the value and its type and also assigns a unique, sequentially named value starting with <code>res0</code> (short for “result”). You can choose to make use of these “result” values just like any value you explicitly define:</p>

<pre><code>scala&gt; res3 * res4
res7: Int = 50
</code></pre>

<p>Here the values <code>res3</code> and <code>res4</code> are multiplied, resulting in the value <code>50</code> being returned and stored in the new value named <code>res7</code>.  <br />
Let’s try working with variables now. Variables, which unlike values are mutable and can be reassigned new values, are defined with the syntax <code>var &lt;name&gt;: &lt;type&gt; = &lt;literal&gt;</code>.</p>

<pre><code>scala&gt; var a: Double = 2.72
a: Double = 2.72

scala&gt; a = 355.0 / 133.0
a: Double = 2.669172932330827

scala&gt; a = 5
a: Double = 5.0
</code></pre>

<p>In this example we defined the variable a to have the type <code>Double</code>, a double-precision floating-point number. And then, because it is a variable, we reassigned it to a different value.</p>

<p>This has been a short introduction to using values, variables, types, and literals in Scala.In the rest of this chapter we will cover each of these subject areas in depth.</p>

<h2 id="values">Values</h2>

<p>Values are immutable, typed storage units, and by convention are the default method for storing data. You can define a new value using the <code>val</code> keyword.</p>

<h3 id="syntax-defining-a-value">Syntax: Defining a Value</h3>

<pre><code>val &lt;identifier&gt;[: &lt;type&gt;] = &lt;data&gt;
</code></pre>

<p>Values require both a name and assigned data, but they do not require an explicit type. If the type is not specified (i.e., the “<code>: &lt;type&gt;</code>” syntax is not included), the Scala compiler will infer the type based on the assigned data.</p>

<p>Here are some examples of defining values with their type in the Scala REPL:</p>

<pre><code>scala&gt; val x:Int = 20
x: Int = 20

scala&gt; val greeting: String = "Hello, World"
greeting: String = Hello, World

scala&gt; val atSymbol: Char = '@'
atSymbol: Char = @
</code></pre>

<p>You may have noticed from the syntax diagram that specifying the type in value definitions is optional. In situations where it is possible to deduce the type of the value based on its assignment (for example, the literal <code>20</code> in the first example is obviously an integer),you can leave off the type from a value definition. The Scala compiler will then discern the type of the value from its assignment, a process known as type inference. <strong>Values defined without a type are not typeless; they are assigned the proper type just as if the type had been included in the definition.</strong></p>

<p>Let’s try the examples again without specifying their types:</p>

<pre><code>scala&gt; val x = 20
x: Int = 20

scala&gt; val greeting = "Hello, World"
greeting: String = Hello, World

scala&gt; val atSymbol = '@'
atSymbol: Char = @
</code></pre>

<p>In this example the values end up having the same types (<code>Int</code>, <code>String</code>, and <code>Char</code>) as they did when the types were explicitly stated. The Scala compiler, via the REPL, was able to deduce that the literal <code>20</code> corresponds to the type <code>Int</code>, the literal “<code>Hello, World</code>” to the type <code>String</code>, and the literal <code>@</code> to the type <code>Char</code>.</p>

<p>Using Scala’s type inference is a helpful shortcut when writing code because it removes the need to explicitly write the type of a value. As a guideline it should only be used when it does not reduce the readability of your code. In the case that someone reading your code would not be able to figure out what the type of the value is, it would be better to include the explicit type in the value definition.</p>

<p>Although type inference will deduce the correct type to use to store data, it will not override an explicit type that you set. If you define a value with a type that is incompatible with the initial value you will get a compilation error:</p>

<pre><code>scala&gt; val x: Int = "Hello"
&lt;console&gt;:10: error: type mismatch;
 found   : String("Hello")
 required: Int
       val x: Int = "Hello"
</code></pre>

<p>The error here affirms that an <code>Int</code> type cannot be used to store a <code>String</code>.</p>

<h2 id="variables">Variables</h2>

<p>In computer science the term variable typically refers to a unique identifier corresponding to an allocated or reserved memory space, into which values can be stored and from which values can be retrieved. As long as the memory space is reserved, it can be assigned new values over and over again. Thus, the contents of the memory space are dynamic, or variable.</p>

<p>In most languages, such as C, Java, PHP, Python, and Ruby, this is the typical pattern for working with named, assignable memory storage. Variables are dynamic, mutable,and reassignable (with the exception of those defined with special restrictions such as Java’s <code>final</code> keyword).</p>

<p>In Scala, values are preferred over variables by convention, due to the stability and predictability they bring to source code. When you define a value you can be assured that it will retain the same value regardless of any other code that may access it. Reading and debugging code is easier when a value assigned at the beginning of a code segment is unchanged through the end of the code segment. Finally, when working with data that may be available for the life span of an application, or accessible from concurrent or multithreaded code, an immutable value will be more stable and less prone to errors than mutable data that may be modified at unexpected times.                          <br />
The example code and exercises in this book prefer the use of values over variables.However, in those places where variables are more suitable, such as local variables that store temporary data or accumulate values in loops, variables will certainly be used.  <br />
Now that the preference for values over variables has been explained in detail, we can put that aside and cover how to use variables in Scala.  <br />
The <code>var</code> keyword is used to define a variable with a given name, type, and assignment.</p>

<h3 id="syntax-defining-a-variable">Syntax: Defining a Variable</h3>

<pre><code>var &lt;identifier&gt;[: &lt;type&gt;] = &lt;data&gt;
</code></pre>

<p>Like values, variables can be defined with or without an explicit type. If no type is specified the Scala compiler will use type inference to determine the correct type to assign to your variable. Unlike values, variables can be reassigned new data at any time.</p>

<p>Here is an example of defining a variable and then reassigning it, in this case to the product of itself and another number:</p>

<pre><code>scala&gt; var x = 5
x: Int = 5

scala&gt; x = x * 4
x: Int = 20
</code></pre>

<p>Although a variable can be reassigned, its designated type cannot, and so a variable cannot be reassigned data that has an incompatible type. For example, defining a variable of type <code>Int</code> and then assigning it a <code>String</code> value will result in a compiler error:   <br />
跟在命令行中可以重复定义变量是不一样的:</p>

<pre><code>scala&gt; var x = "Hello, world"
x: String = Hello, world

scala&gt; var x = 5
x: Int = 5
</code></pre>

<p>只有在命令行中才可以这样做</p>

<pre><code>cala&gt; var x = 5
x: Int = 5

scala&gt; x = "what's up?"
&lt;console&gt;:11: error: type mismatch;
 found   : String("what\'s up?")
 required: Int
       x = "what's up?"
</code></pre>

<p>However, defining a variable of type <code>Double</code> and assigning it an <code>Int</code> value will work because <code>Int</code> numbers can be converted to <code>Double</code> numbers automatically:</p>

<pre><code>scala&gt; var y = 1.5
y: Double = 1.5

scala&gt; y = 42
y: Double = 42.0
</code></pre>

<h2 id="naming">Naming</h2>

<p>Scala names can use letters, numbers, and a range of special operator characters. This makes it possible to use standard mathematical operators (e.g., <code>*</code> and <code>:+</code>) and constants (e.g., <code>π</code> and <code>φ</code>) in place of longer names to make the code more expressive.                       <br />
The Scala Language Specification defines these operator characters as “all other characters in \u0020-007F<code> and Unicode categories Sm [Symbol/Math] ... except parentheses (</code>[]`) and periods.” Square brackets (referred to in the text as parentheses) are reserved for use in type parameterization, while periods are reserved for access to the fields and methods of objects (instantiated types).</p>

<p>Here are the rules for combining letters, numbers, and characters into valid identifiers  in Scala:</p>

<ul>
  <li>A letter followed by zero or more letters and digits.</li>
  <li>A letter followed by zero or more letters and digits, then an underscore (<code>_</code>), and then one or more of either letters and digits or operator characters.</li>
  <li>One or more operator characters.</li>
  <li>One or more of any character except a backquote, all enclosed in a pair of backquotes.</li>
</ul>

<p>Names enclosed in backquotes(就是这个``符号) can, unlike the other names, be reserved keywords in Scala such as <code>true</code>, <code>while</code>, <code>=</code>, and <code>var</code>.</p>

<p>Let’s try out some of these naming rules in the REPL:</p>

<pre><code>scala&gt; val π = 3.14159
π: Double = 3.14159
</code></pre>

<p>The special character “π” is a valid Scala identifier.</p>

<pre><code>scala&gt; val $ = "USD currency symbol"
$: String = USD currency symbol




scala&gt; val o_O = "Hmm"
o_O: String = Hmm

scala&gt; val 50cent = "$0.50"
&lt;console&gt;:1: error: Invalid literal number
val 50cent = "$0.50"
    ^
</code></pre>

<p>The value name “<code>50cent</code>” is invalid because names cannot start with numbers.In this case the compiler started parsing the name as a literal number and ran into problems at the letter “<code>c</code>”.</p>

<pre><code>scala&gt; val a.b = 25
&lt;console&gt;:11: error: value b is not a member of Int
       val a.b = 25
	     ^ The value name “a.b” is invalid because a period isn’t an operator character.                

scala&gt; val `a.b` = 4
a.b: Int = 4
</code></pre>

<p>Rewriting this value with backquotes fixes the problem, although the aesthetics of using backquotes isn’t that great.</p>

<p>Value and variable names, by convention, should start with a lowercase letter and then capitalize additional words. This is popularly known as camel case, and though not required it is recommended for all Scala developers. This helps to distinguish them from types and classes which (also by convention, not by rule) follow camel case but start with an uppercase letter.</p>

<h2 id="types">Types</h2>

<p>Scala has both numeric (e.g., <code>Int</code> and <code>Double</code>) and nonnumeric types (e.g., <code>String</code>) that can be used to define values and variables. These core types are the building blocks for all other types including objects and collections, and are themselves objects that have methods and operators that act on their data.</p>

<p>Unlike Java and C there is no concept of a primitive type in Scala. While the Java Virtual Machine supports the primitive integer type <code>int</code> and the integer class <code>Integer</code>, Scala only supports its own integer class, <code>Int</code>.</p>

<h3 id="numeric-data-types">Numeric Data Types</h3>

<p>Table 2-1 displays Scala’s numeric data types.</p>

<p>Table 2-1. Core numeric types</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: center">Size</th>
      <th style="text-align: center">Min</th>
      <th style="text-align: center">Max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Byte</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">1 byte</td>
      <td style="text-align: center">–127</td>
      <td style="text-align: center">128</td>
    </tr>
    <tr>
      <td style="text-align: center">Short</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">2 bytes</td>
      <td style="text-align: center">–32768</td>
      <td style="text-align: center">32767</td>
    </tr>
    <tr>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">–2^31</td>
      <td style="text-align: center">2^31–1</td>
    </tr>
    <tr>
      <td style="text-align: center">Long</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">8 bytes</td>
      <td style="text-align: center">–2^63</td>
      <td style="text-align: center">2^63–1</td>
    </tr>
    <tr>
      <td style="text-align: center">Float</td>
      <td style="text-align: center">Signed floating point</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">n/a</td>
      <td style="text-align: center">n/a</td>
    </tr>
    <tr>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">Signed floating point</td>
      <td style="text-align: center">8 bytes</td>
      <td style="text-align: center">n/a</td>
      <td style="text-align: center">n/a</td>
    </tr>
  </tbody>
</table>

<p>See the API documentation for <code>java.lang.Float</code> and <code>java.lang.Double</code> for a description of the calculated maximum and minimum values for these floating-point numbers.</p>

<p>Scala supports the ability to automatically convert numbers from one type to another based on the rank of the type. The numeric types in Table 2-1 are sorted by their automatic conversion rank, where the Byte type is the lowest and can be converted to any other type.</p>

<p>Let’s try this out by creating values of different types and automatically converting them to higher-ranked types:</p>

<pre><code>scala&gt; val b: Byte = 10
b: Byte = 10

scala&gt; val s: Short = b
s: Short = 10

scala&gt; val d: Double = s
d: Double = 10.0
</code></pre>

<p>The <code>b</code> and <code>s</code> values here were assigned to new values that had a higher rank, and so were automatically converted (or “upconverted” as some say) to the higher ranks.</p>

<p>Java developers will recognize the names of these types, which are wrappers around the core JVM types of the same names (except the JVM’s <code>Integer</code> is Scala’s <code>Int</code>). Wrapping JVM types ensures that Scala and Java are interopable, and that Scala can make use of every Java library.</p>

<p><strong>Scala does not allow automatic conversion from higher ranked types to lower ranked types.</strong> This makes sense, because you could otherwise lose data if you convert to a type with less storage. Here is an example of trying to automatically convert a higher ranked type to a lower ranked type and the ensuing error:</p>

<pre><code>scala&gt; val l: Long = 20
l: Long = 20

scala&gt; val i: Int = l
&lt;console&gt;:11: error: type mismatch;
 found   : Long
 required: Int
       val i: Int = l
		    ^
</code></pre>

<p>You can choose to manually convert between types using the <code>toType</code> methods available on all numeric types. Although this makes it possible to lose data by converting to a lesser ranked type, it is useful when you know that the data is compatible with the lower ranked type.</p>

<p>For example, here is a <code>Long</code> value that can be safely converted to type <code>Int</code> using the <code>toInt</code> method, because its data is within the storage bounds of an <code>Int</code>:</p>

<pre><code>scala&gt; val l: Long = 20
l: Long = 20

scala&gt; val i: Int = l.toInt
i: Int = 20
</code></pre>

<p>我这时候就想：如果是超过了低精度类型的数呢:</p>

<pre><code>scala&gt; val l: Long = 999999999999999999l
l: Long = 999999999999999999

scala&gt; val i: Int = l.toInt
i: Int = -1486618625
</code></pre>

<p>Scala并没有报错，是可以的</p>

<p>An alternative to using explicit types is to specify the type of your literal data directly,using Scala’s notation for literal types. See Table 2-2 for the full list of notations for specifying the types of literals.</p>

<p>Table 2-2. Numeric literals</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Literal</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">Unadorned（adj. 朴素的；未装饰的） integer literals are <code>Int</code> by default</td>
    </tr>
    <tr>
      <td style="text-align: center">0x0f</td>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">The “0x” prefix denotes hexadecimal notation</td>
    </tr>
    <tr>
      <td style="text-align: center">5l</td>
      <td style="text-align: center">Long</td>
      <td style="text-align: center">The “<code>l</code>” suffix denotes a <code>Long</code> type</td>
    </tr>
    <tr>
      <td style="text-align: center">5.0</td>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">Unadorned decimal literals are <code>Double</code> by default</td>
    </tr>
    <tr>
      <td style="text-align: center">5f</td>
      <td style="text-align: center">Float</td>
      <td style="text-align: center">The “<code>f</code>” suffix denotes a <code>Float</code> type</td>
    </tr>
    <tr>
      <td style="text-align: center">5d</td>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">The “<code>d</code> suffix denotes a <code>Double</code> type</td>
    </tr>
  </tbody>
</table>

<h3 id="literal-characters-are-case-insensitive">Literal Characters Are Case-Insensitive</h3>

<p>You can use either lowercase or uppercase letters in Scala’s literal types.The literal number <code>5L</code> is the same as the literal number <code>5l</code>.</p>

<p>Let’s try out these literals by assigning them to new values without stating the type. The Scala REPL will use type inference to calculate the appropriate types for each value:</p>

<pre><code>scala&gt; val anInt = 5
anInt: Int = 5

scala&gt; val yellowRgb = 0xffff00
yellowRgb: Int = 16776960

scala&gt; val id = 100l
id: Long = 100

scala&gt; val pi = 3.1416
pi: Double = 3.1416
</code></pre>

<h2 id="strings">Strings</h2>

<p>The <code>String</code> type represents “strings” of text, one of the most common core types in any programming language. Scala’s <code>String</code> is built on Java’s <code>String</code> and adds unique features like multiline literals and string interpolation(n. 插入；篡改；添写).</p>

<p>Write <code>String</code> literals using double quotes, with special characters escaped with backslashes:</p>

<pre><code>scala&gt; val hello = "Hello There"
hello: String = Hello There

scala&gt; val signature = "With Regards, \nYour friend"
signature: String =
With Regards,
Your friend
</code></pre>

<p>Like numeric types, the <code>String</code> type supports the use of math operators. For example,use the equals operator (<code>==</code>) to compare two <code>String</code> values. Unlike Java, the equals operator (<code>==</code>) checks for <code>true</code> equality, not object reference equality:</p>

<pre><code>scala&gt; val greeting = "Hello, " + "World"
greeting: String = Hello, World

scala&gt; val matched = (greeting == "Hello, World")
matched: Boolean = true

scala&gt; val theme = "Na " * 16 + "Batman!" //what do you expect this to print
theme: String = Na Na Na Na Na Na Na Na Na Na Na Na Na Na Na Na Batman!
</code></pre>

<p>A multiline <code>String</code> can be created using triple-quotes. Multiline strings are literal, and so do not recognize the use of backslashes as the start of special characters:</p>

<pre><code>scala&gt; val greeting = """She suggested reformatting the file
     | by replacing tabs (\t) with newlines (\n);
     | "Why do that?", he asked."""
greeting: String =
She suggested reformatting the file
by replacing tabs (\t) with newlines (\n);
"Why do that?", he asked.
</code></pre>

<h3 id="string-interpolation">String interpolation</h3>

<p>Building a <code>String</code> based on other values is reasonably easy to do with string addition.Here is a <code>String</code> built by adding text before and after the <code>Float</code> value:</p>

<pre><code>scala&gt; val approx = 355/113f
approx: Float = 3.141593

scala&gt; println("Pi, using 355/113, is about " + approx + ".")
Pi, using 355/113, is about 3.141593.
</code></pre>

<p>A more direct way to combine your values or variables inside a <code>String</code> is with string interpolation, a special mode where external value and variable names are recognized and resolved. The Scala notation for string interpolation is an “<code>s</code>” prefix added before the first double quote of the string. Then dollar sign operators (<code>$</code>) (with optional braces) can be used to note references to external data.(抄php的) <br />
Here is the example again using string interpolation:</p>

<pre><code>scala&gt; println(s"Pi, using 355/113, is about $approx.")
Pi, using 355/113, is about 3.141593.
</code></pre>

<p>You will need the optional braces if you have any nonword characters in your reference (such as a calculation), or if your reference can’t be distinguished from the surrounding text:</p>

<pre><code>scala&gt; val item = "apple"
item: String = apple

scala&gt; s"How do you like tem ${item}s"
res1: String = How do you like tem apples

scala&gt; s"Fish n chips n vinegar,${"papper " * 3}salt"
res2: String = Fish n chips n vinegar,papper papper papper salt
</code></pre>

<p>An alternate format for string interpolation uses <code>printf</code> notation, very useful when you want to control the data formatting such as the character count or display of decimal values. To use <code>printf</code> notation change the prefix to an “<code>f</code>” and follow the end of the reference immediately with the <code>printf</code> notation: <br />
If you are unfamiliar with <code>printf</code> there are numerous online references for the format, including the official Javadoc for <code>java.util.Formatter</code>, the underlying engine used by Scala to format these strings.</p>

<pre><code>scala&gt; val item = "apple"
item: String = apple

scala&gt; f"I wrote a new $item%.3s today"
res4: String = I wrote a new app today

scala&gt; f"Enjoying this $item ${355/113.0}%.5f times today"
res5: String = Enjoying this apple 3.14159 times today
</code></pre>

<p>These <code>printf</code> notations make the references a little harder to read than in the previous examples, but do provide essential control over the output.</p>

<p>Now that we have learned how to control data output with strings, let’s find out how to do the opposite with regular expressions.</p>

<h2 id="regular-expressions">Regular expressions</h2>

<p>A regular expression is a string of characters and punctuation that represents a search pattern. Popularized by Perl and command-line utilities like Grep, regular expressions are a standard feature in the libraries of most programming languages including Scala.</p>

<p>The format for Scala’s regular expressions is based on the Java class <code>java.util.regex.Pattern</code>. I recommend reading the Javadoc (the Java API documentation) for <code>java.util.regex.Pattern</code> if you are unfamiliar with this type, because Java’s (and thus Scala’s) regular expressions may be different from the format you have used with other languages and tools.</p>

<p>The <code>String</code> type provides a number of built-in operations that support regular expressions. Table 2-3 displays a selection of these operations.</p>

<h3 id="table-2-3-regular-expression-operations">Table 2-3. Regular expression operations</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Example</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">matches</td>
      <td style="text-align: center">“Froggy went a’ courting” matches “.* courting”</td>
      <td style="text-align: center">Returns true if the regular expression matches the entire string.</td>
    </tr>
    <tr>
      <td style="text-align: center">Description</td>
      <td style="text-align: center">“milk, tea, muck” replaceAll (“m[^ ]+k”, “coffee”)</td>
      <td style="text-align: center">Replaces all matches with replacement text.</td>
    </tr>
    <tr>
      <td style="text-align: center">replaceFirst</td>
      <td style="text-align: center">“milk, tea, muck” replaceFirst (“m[^ ]+k”, “coffee”)</td>
      <td style="text-align: center">Replaces the first match with replacement text.</td>
    </tr>
  </tbody>
</table>

<p>For more advanced handling of regular expressions, convert a string to a regular expression type by invoking its <code>r</code> operator. This will return a Regex instance that can handle additional search and replace operations as well as capture group support. A capture group makes it possible to select items in a given string and convert them to local values based on the regular expression pattern. The pattern must include at least one capture group defined by parentheses, and the input must include at least one of the captured patterns to return the value.</p>

<h4 id="syntax-capturing-values-with-regular-expressions">Syntax: Capturing Values with Regular Expressions</h4>

<pre><code>val &lt;Regex value&gt;(&lt;identifier&gt;) = &lt;input string&gt;
</code></pre>

<p>Let’s try this out by capturing the numeric value from the output of the previous example (see “String interpolation” on page 18). We’ll use multiline strings to store our regular expression pattern, because they are literal and allow us to write a backslash without a second, escaping backslash:</p>

<pre><code>scala&gt; val input = "Enjoying this apple 3.14159 times today"
input: String = Enjoying this apple 3.14159 times today

scala&gt; val pattern = """.* apple ([\d.]+) times .*""".r
</code></pre>

<p>The capture group is the series of digits and a period between the words <code>apple</code> and <code>times</code>.</p>

<pre><code>pattern: scala.util.matching.Regex = .* apple ([\d.]+) times .*
</code></pre>

<p>The full regular expression type is <code>scala.util.matching.Regex</code>, or just <code>util.matching.Regex</code>.</p>

<pre><code>scala&gt; val pattern(amountText) = input
amountText: String = 3.14159
</code></pre>

<p>The format is admittedly a bit odd. The name of the new value containing the capture group match, <code>amountText</code>, does not directly follow the <code>val</code> identifier.</p>

<pre><code>scala&gt; val amount = amountText.toDouble
amount: Double = 3.14159
</code></pre>

<p>After converting the amount in text form to a <code>Double</code> we have our numeric value.</p>

<p>Regular expressions serve as a compact and efficient means to process text, with operations such as matching, replacing, and capturing. If you are still new to regular expressions, it is worth investing time to study them because they are widely applicable in modern software development.</p>

<pre><code>scala&gt; val pattern(amountText) = input
scala.MatchError: tt (of class java.lang.String)
  ... 33 elided
</code></pre>

<p>如果没有匹配项就会报错</p>

<h2 id="an-overview-of-scala-types">An Overview of Scala Types</h2>

<p>In this section we will move on from numbers and strings to a broader look at the range of core types. All of Scala’s types, from numbers to strings to collections, exist as part of a type hierarchy. Every class that you define in Scala will also belong to this hierarchy automatically.</p>

<p>Figure 2-1 shows the hierarchy of Scala’s core (numeric and nonnumeric) types.    <br />
<img src="http://scalajiaocheng.github.io/images/scala/Figure 2-1. The Scala type hierarchy.png" alt="Figure 2-1. The Scala type hierarchy" /></p>

<p>The open-headed arrows in the diagram indicate supertypes, a common notation in object-oriented diagrams. The multiple-arrow types at the bottom indicate that they are subtypes of every type in the system, including classes you define on your own.  <br />
In Table 2-4 you can see a full listing of the specific types mentioned in this diagram, followed by more complete descriptions.</p>

<h3 id="table-2-4-core-nonnumeric-types">Table 2-4. Core nonnumeric types</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: center">Instantiable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Any</td>
      <td style="text-align: center">The root of all types in Scala</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">AnyVal</td>
      <td style="text-align: center">The root of all value types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">AnyRef</td>
      <td style="text-align: center">The root of all reference (nonvalue) types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Nothing</td>
      <td style="text-align: center">The subclass of all types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Null</td>
      <td style="text-align: center">The subclass of all AnyRef types signifying a null value</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Char</td>
      <td style="text-align: center">Unicode character</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">Boolean</td>
      <td style="text-align: center">true or false</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">String</td>
      <td style="text-align: center">A string of characters (i.e., text)</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">Unit</td>
      <td style="text-align: center">Denotes the lack of a value</td>
      <td style="text-align: center">No</td>
    </tr>
  </tbody>
</table>

<p>The <code>Any</code>, <code>AnyVal</code>, and <code>AnyRef</code> types are the root of Scala’s type hierarchy. <code>Any</code> is the absolute root, and all other types descend from its two children, <code>AnyVal</code> and <code>AnyRef</code>.The types that extend <code>AnyVal</code> are known as value types because they are the core values used to represent data. They include all of the numeric types we have covered plus <code>Char</code>,<code>Boolean</code>, and <code>Unit</code>. <code>AnyVal</code> types are accessed just like other types but may be allocated at runtime either on the heap as objects or locally on the stack as a JVM primitive value.All other types have <code>AnyRef</code> as their root and are only ever allocated on the heap as objects. The term “<code>Ref</code>“ in “<code>AnyRef</code> ” indicates they they are reference types that are accessed via a memory reference.</p>

<p>At the bottom of the Scala type hierarchy are the <code>Nothing</code> and <code>Null</code> types. <code>Nothing</code> is a subtype of every other type and exists to provide a compatible return type for operations that significantly affect a program’s flow. For example, the <code>return</code> keyword, which exits a function early with a return value, has a return type of <code>Nothing</code> so it can be used in the middle of initializing a value and not affect the type of that value. <code>Nothing</code> is only used as a type, because it cannot be instantiated.</p>

<p>The other bottom type is <code>Null</code>, a subtype of all <code>AnyRef</code> types that exists to provide a type for the keyword <code>null</code>. A <code>String</code> variable, for example, can be assigned <code>null</code> at any time,such that the variable does not point to any string instance in memory. This assignment of <code>null</code> to a variable declared as type <code>String</code> is acceptable because <code>null</code> is a compatible type for <code>String</code>. Defining a type for <code>null</code> is an example of how Scala’s syntax prefers the use of real types and instances to reserved keywords.      <br />
<code>Char</code> is the only type that could also appear in “Numeric Data Types” on page 15. As the basis of the <code>String</code> type it contains a single character and so is sometimes considered to be a unit of text. Essentially it is a scalar type that can be converted to and from other numbers.    <br />
<code>Char</code> literals are written with single quotes, distinguishing them from <code>String</code> literals,which are written with double quotes. If you’re familiar with the ASCII character numbering system, this example should be obvious:</p>

<pre><code>scala&gt; val c = 'A'
c: Char = A

scala&gt; val i: Int = c
i: Int = 65

scala&gt; val t: Char = 116
t: Char = t
</code></pre>

<p>The <code>Boolean</code> type is limited to the values <code>true</code> and <code>false</code>. In addition to using <code>true</code> and <code>false</code>, you can also obtain <code>Boolean</code> values from comparison and <code>Boolean</code> logic operators:</p>

<pre><code>scala&gt; val isTrue = !true
isTrue: Boolean = false

scala&gt; val isFalse = !true
isFalse: Boolean = false

scala&gt; val unequal = (5 != 6)
unequal: Boolean = true

scala&gt; val isLess = (5 &lt; 6)
isLess: Boolean = true

scala&gt; val unequalAndLess = unequal &amp; isLess
unequalAndLess: Boolean = true

scala&gt; val definitelyFalse = false &amp;&amp; unequal
definitelyFalse: Boolean = false
</code></pre>

<h4 id="what-is-the-difference-between--and--">What is the Difference Between &amp; and &amp;&amp; ?</h4>

<p>The <code>Boolean</code> comparison operators <code>&amp;&amp;</code> and <code>||</code> are lazy in that they will not bother evaluating the second argument if the first argument is sufficient. The operators <code>&amp;</code> and <code>|</code> will always check both arguments  <br />
Unlike many dynamic languages, Scala does not support automatic conversion of other types to <code>Booleans</code>. A nonnull string cannot be evaluated as <code>true</code>, and the number zero does not equal <code>false</code>. If you need to evaluate a value’s state to a <code>Boolean</code>, use an explicit comparison:</p>

<pre><code>scala&gt; val zero = 0
zero: Int = 0

scala&gt; val isValid = zero &gt; 0
isValid: Boolean = false
</code></pre>

<p>The <code>Unit</code> type is unlike the other core types here (numeric and nonnumeric) in that instead of denoting a type of data it denotes the lack of data. In a way it is similar to the <code>void</code> keyword used in Java and C, which is used to define a function that doesn’t return data. The <code>Unit</code> type is similarly used in Scala as the return type for functions or expressions that don’t return anything. For example, the common <code>println</code> function could be said to return a <code>Unit</code> type because it returns nothing.  <br />
The <code>Unit</code> literal is an empty pair of parentheses, <code>()</code>, which if you consider it is a fine representation of not having a value. If you want you can define a value or variable with the <code>Unit</code> type, but again its common usage is for defining functions and expressions:</p>

<pre><code>scala&gt; val nada = ()
nada: Unit = ()
</code></pre>

<p>Now that we have covered the core types, let’s have a look at the operations they all have in common.</p>

<h3 id="type-operations">Type operations</h3>

<p>Table 2-5 displays the operations available on all types in Scala. The <code>toString</code> and <code>hashCode</code> methods are required on all JVM instances.</p>

<h4 id="table-2-5-common-type-operations">Table 2-5. Common type operations</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Example</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">asInstanceOf[<type>]</type></td>
      <td style="text-align: center">5.asInstanceOf[Long]</td>
      <td style="text-align: center">Converts the value to a value of the desired type.</td>
    </tr>
    <tr>
      <td style="text-align: center">getClass</td>
      <td style="text-align: center">(7.0 / 5).getClass</td>
      <td style="text-align: center">Returns the type (i.e., the class) of a value.</td>
    </tr>
    <tr>
      <td style="text-align: center">isInstanceOf</td>
      <td style="text-align: center">(5.0).isInstanceOf[Float]</td>
      <td style="text-align: center">Returns true if the value has the given type.</td>
    </tr>
    <tr>
      <td style="text-align: center">hashCode</td>
      <td style="text-align: center">“A”.hashCode</td>
      <td style="text-align: center">Returns the hash code of the value, useful for hash-based collections.</td>
    </tr>
    <tr>
      <td style="text-align: center">to<type></type></td>
      <td style="text-align: center">20.toByte; 47.toFloat</td>
      <td style="text-align: center">Conversion functions to convert a value to a compatible value.</td>
    </tr>
    <tr>
      <td style="text-align: center">toString</td>
      <td style="text-align: center">(3.0 / 4.0).toString</td>
      <td style="text-align: center">Renders the value to a String.</td>
    </tr>
  </tbody>
</table>

<h5 id="avoid-asinstanceof">Avoid asInstanceOf</h5>

<p>The <code>asInstanceOf</code> operation will cause an error if the value cannot be converted to the requested type. To avoid runtime errors with this operation, prefer the <code>to&lt;type&gt;</code> typed conversion operations when possible.</p>

<p>The types we have covered so far in this chapter are all (with the possible exception of <code>String</code>) scalar values, which represent a single element (or, of course with <code>Unit</code>, the lack of any element). As a complement to these scalar values, we will finish the chapter with the <code>Tuple</code> type, which can collect two or more of these values into a new,ordered element.</p>

<h3 id="tuples">Tuples</h3>

<p>A tuple is an ordered container of two or more values, all of which may have different types. You may be familiar with this term from working with relational databases, where a single row of a table is considered its own tuple. Tuples can be useful when you need to logically group values, representing them as a coherent unit. Unlike lists and arrays, however, there is no way to iterate through elements in a tuple. Its purpose is only as a container for more than one value.</p>

<p>You can create a tuple by writing your values separated by a comma and surrounded by a pair of parentheses.</p>

<h4 id="syntax-create-a-tuple">Syntax: Create a Tuple</h4>

<pre><code>( &lt;value 1&gt;, &lt;value 2&gt;[, &lt;value 3&gt;...] )
</code></pre>

<p>For example, here is a tuple containing <code>Int</code>, <code>String</code>, and <code>Boolean</code> values:</p>

<pre><code>scala&gt; val info = (5, "Korben", true)
ifno: (Int, String, Boolean) = (5,Korben,true)
</code></pre>

<p>You can access an individual element from a tuple by its 1-based index (e.g., where the first element is 1, second is 2, etc.):</p>

<pre><code>scala&gt; val name = info._2
name: String = Korben
</code></pre>

<p>An alternate form of creating a 2-sized tuple is with the relation operator (<code>-&gt;</code>). This is a popular shortcut for representing key-value pairs in tuples:</p>

<pre><code>scala&gt; val red = "red" -&gt; "oxff0000"
red: (String, String) = (red,oxff0000)

scala&gt; val reversed = red._2 -&gt; red._1
reversed: (String, String) = (oxff0000,red)
</code></pre>

<p>Tuples provide a generic means to structure data, and are useful when you need to group discrete elements for handling.</p>

<h2 id="summary">Summary</h2>

<p>This may be a challenging chapter to see through to the end, because you had to read all about types and data without learning how to do real programming in Scala yet. I’m glad you did.</p>

<p>What was the oddest or most-unexpected part of this chapter? The use of keywords to announce value and variable definition? The reversed manner (if you’re coming from Java) of defining a variable’s name before its type? The idea that much of your code can use fixed, nonreassignable values instead of (variable) variables?</p>

<p>If these ideas were hard to take, the good news is that, as you gain experience in Scala developemnt, they will become quite normal. Eventually they may even seem to be obvious choices for a well-designed functional programming language.</p>

<p>At this point you should know how to define your own values and variables, although we haven’t yet learned where to come up with useful data to store in them. In the next chapter you will study ways to derive and calculate this data using logical structures known as expressions.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Scala CHAPTER 1 Getting Started with the ScalableLanguage]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-1-getting-started-with-the-scalablelanguage/"/>
    <updated>2015-12-29T22:04:10+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-1-getting-started-with-the-scalablelanguage</id>
    <content type="html"><![CDATA[<p>The Scala programming language has a wonderfully continental(adj. 大陆的；大陆性的) ring to its name, as befits its origins at the École polytechnique fédérale de Lausanne (EPFL) in Lausanne,Switzerland. The Scala logo represents a circular stairway, which may lead you to believe its origin is the term <strong>La Scala</strong>, meaning a staircase or ladder in Italian, or that it derives from the famous Italian opera house <strong>Teatro alla Scala</strong>. In fact the name Scala is an abbreviation of the term SCAlable LAnguage, a fitting description of its intention. Professor Martin Odersky and his group at EPFL created the language in 2003 to provide a high-performance, concurrent-ready environment for functional programming and object-oriented programming on the Java Virtual Machine (JVM) platform.                          <br />
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#installing-scala" id="markdown-toc-installing-scala">Installing Scala</a></li>
  <li><a href="#using-the-scala-repl" id="markdown-toc-using-the-scala-repl">Using the Scala REPL</a></li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<h2 id="installing-scala">Installing Scala</h2>

<p>As a JVM language, Scala requires the use of a Java runtime. Scala 2.11, the version you’ll be using, needs at least Java 6. However, I recommend installing the Java 8 JDK (aka Java SE for Standard Environment) instead for optimal performance. You can download the Java 8 JDK (or a later version, if available) for most platforms directly from Oracle’s website. Installers are available, so you shouldn’t need to manually configure your <code>PATH</code> variable to get the applications installed.</p>

<p>When finished, verify your Java version by running <code>java -version</code> from the command line. Here is an example of running this command for Java 8:</p>

<pre><code>$ java -version
java version "1.8.0_05"
Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)
</code></pre>

<p>Now that Java is installed, it’s time to install Scala. There are two ways to install Scala (or any other fine programming tool): the manual approach, suitable for command-line heroes who like to modify their system’s environment variables, and the automatic approach, for the rest of us.</p>

<p>To install Scala manually, download the Scala 2.11 distribution from http://www.scala-lang.org and add its “<code>bin</code>” directory to your path. The distribution includes the Scala runtimes, tools, compiled libraries, and source, but the most important item we’ll need is the scala command. This command provides (among other features) the REPL(Read-Eval-Print-Loop) shell we will use to learn and experiment with the Scala language.</p>

<p>To install Scala automatically, use a package manager such as Homebrew for OS X,Chocolatey for Windows, or apt-get/Yum for Linux systems. These are freely available and will handle finding the package, downloading and extracting it, and installing it so you can access it from the command line. The scala package is available in all of these package managers as “scala,” so you can install it with (<code>brew</code>/<code>choco</code>/<code>apt-get-yum</code>) <code>install scala</code>.</p>

<p>When installed, execute the <code>scala</code> command from the command line. You should see a welcome message like the following (although your Scala and Java version messages may be different):</p>

<pre><code>$ scala
Welcome to Scala version 2.11.0 (Java HotSpot(TM) 64-Bit Server VM,
Java 1.8.0_05).
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;
</code></pre>

<p>When you see the <code>Welcome to Scala</code> message and the <code>scala&gt;</code> prompt you are now in the Scala REPL and are ready to start coding.</p>

<p>If the command is found but there are problems launching it, make sure your Java command is installed correctly and that your system path points to the correct Java version.</p>

<h2 id="using-the-scala-repl">Using the Scala REPL</h2>

<p>If you have used other REPL shells like Python’s python, Ruby’s irb, or Groovy’s groovysh you’ll find the Scala REPL familiar. As with the REPL’s provided with the Python, Ruby,and Groovy runtimes, Scala’s REPL provides support for evaluating and executing code one line at a time with helpful feedback.</p>

<p>If you haven’t used a REPL, or are just unaccustomed to writing code outside an IDE or editor, it will take some practice to learn how to develop in the Scala REPL. However,it provides an unsurpassed way to learn and experiment quickly and responsively with the Scala language and libraries. You can enter single lines of code to evaluate and compile, and any variables you create are available for the lifetime of your session. A multiline paste mode supports entering multiple lines of code to be compiled together (instead of individually), and external source code and libraries can be loaded at any time. A help system is available and can be started by entering the <code>:help</code> command.</p>

<p>Let’s get started using the REPL by implementing the classic first exercise of all serious programming books, the “Hello World” application. Start up the REPL and make sure you see the <code>scala&gt;</code> prompt on your screen:</p>

<pre><code>scala&gt;
</code></pre>

<p>After the prompt type <code>println("Hello, World!")</code> and press <code>Return</code>. The REPL will run your <code>println()</code> command and print the output on a line below your command.Following the printout will be another <code>scala&gt;</code> prompt, waiting for a new command to run. This is the Read, Evaluate, Print, Loop behavior from which the REPL derives its name.</p>

<p>Here is how the input and response should appear in the REPL:</p>

<pre><code>scala&gt; println("Hello world!")
Hello world!

scala&gt; 
</code></pre>

<p>Congratulations, you have now written and executed Scala code.</p>

<p>The <code>println()</code> function, universally available to all Scala code, prints a message to the JVM’s stdout stream. When used in application servers that stdout stream is typically logged to a file (e.g., Tomcat’s <code>catalina.out</code>), but in the Scala REPL the <code>println()</code> function’s messages appear directly in the REPL.</p>

<p>You can use standard readline-style up-arrow and down-arrow keys to navigate to the previous and next input lines. For example, press the up-arrow key and hit Return to rerun the previous command, or press up arrow and enter a new message to print. REPL history is stored between sessions, so you can quit, run the scala command again, and press up arrow to access your previous commands.</p>

<p>Let’s try performing a simple arithmetic operation. At a new prompt type <code>5 * 7</code> and press Return. Your display should look like this:</p>

<pre><code>scala&gt; 5 * 7
res1: Int = 35

scala&gt; 
</code></pre>

<p>This time your Scala command did not print output, but instead returned a value, the product of <code>5</code> and <code>7</code>. When your commands return (or are themselves) values, the REPL will assign them to a new, constant variable so that you can refer to the value in later operations. These “<code>res</code>” variables (a shortened version of “<code>result</code>,” perhaps) are sequentially numbered so that there will always be a unique container for your command’s result.   <br />
Now that <code>res1</code> contains the output of the multiplication command, lets make use of it.Type <code>2 * res1</code> at a fresh prompt and press Return. You should see something like this:  <br />
	scala&gt; 2 * res1
	res2: Int = 70</p>

<p>As expected, the REPL recognized the <code>res1</code> variable it previously created in your arithmetic expression, and generated a new variable <code>res2</code> to store the result of the new expression.</p>

<h2 id="summary">Summary</h2>

<p>I hope you’ve seen how using the Scala REPL to evaluate and experiment with code provides an enriched learning environment for this programming language. As you continue through this book, keep the REPL open and use it to validate everything you learn. The code samples throughout the book are presented as raw captures of REPL sessions to both validate that they work and what they print out, and also to make it easier for you to replicate them in your own REPL session.  <br />
Even better, modify and rework code examples until they break. Scala is a compiled,statically typed language, so the REPL (which compiles a line after you hit Return) will let you know immediately if you have entered incorrect Scala code or not. This will help you pick up the language more quickly and better understand the limits of its syntax and features.</p>

]]></content>
  </entry>
  
</feed>
