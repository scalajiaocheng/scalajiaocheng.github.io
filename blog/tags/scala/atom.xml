<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Scala | Scala教程]]></title>
  <link href="http://scalajiaocheng.github.io/blog/tags/scala/atom.xml" rel="self"/>
  <link href="http://scalajiaocheng.github.io/"/>
  <updated>2016-01-06T00:42:02+08:00</updated>
  <id>http://scalajiaocheng.github.io/</id>
  <author>
    <name><![CDATA[Scala教程]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scala的虚无与飘渺]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2016/01/03/scalade-xu-wu-yu-piao-miao/"/>
    <updated>2016-01-03T17:46:05+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2016/01/03/scalade-xu-wu-yu-piao-miao</id>
    <content type="html"><![CDATA[<p>Null-&gt;null <br />
Nothing <br />
Nil-&gt;List[Nothing]  <br />
None-&gt;Option <br />
Unit  <br />
很多人抱怨Scala相比于Java过于复杂了：大部分使用过Scala的程序员都没有能深刻理解它的类型系统和Scala的函数式编程。Scala的类型系统跟Java和C++很不一样，Scala想把面向对象纯粹化（学院派的作风？），不能有破坏面向对象的一切因素出现。<code>null</code>、<code>NULL</code>、<code>int</code>、…这些都是不和谐的东西，应该割掉。Scala又给了太多了空间给程序员，你可以使用传统的命令式编程风格，也可以使用函数式风格，一个语言写出了不同的代码。这个跟汉语有很多方言，极为相似。太多的自由会浪费Scala的一片好心。一个思路是在封装完Java的功能后，尽量使用Scala推荐的函数式风格来写面向对象的程序。  <br />
进入Scala，你就进入了虚无缥缈的太虚境地。在何为有？何为无？的问题上？Scala的设计走得很远。Scala的有即<code>Any</code>，Scala的无是<code>Null</code>，<code>null</code>，<code>Nil</code>，<code>Nothing</code>，<code>None</code>，<code>Unit</code>。Scala的无太让人手足无措，今天就讨论Scala的无。  <br />
要想在正确的地方使用正确的无，就要先理解它们分别表示的含义。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#nullnull" id="markdown-toc-nullnull">Null&amp;null</a></li>
  <li><a href="#nil" id="markdown-toc-nil">Nil</a></li>
  <li><a href="#nothing" id="markdown-toc-nothing">Nothing</a></li>
  <li><a href="#none" id="markdown-toc-none">None</a></li>
  <li><a href="#unit" id="markdown-toc-unit">Unit</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<h2 id="nullnull">Null&amp;null</h2>

<p>很多人一辈子都没有走出这个无。<code>Null</code>是一个<code>Trait</code>，你不能创建她它的实例。但是Scala在语言层面上存在一个<code>Null</code>的实例，那就是<code>null</code>。Java中的<code>null</code>意味着引用并没有指向任何对象。但存在一个悖论，一切都是对象，那没有对象是不是也是对象呢？Scala定义了一个类似于对象语义的<code>Null</code>，和一个值语义的<code>null</code>。这样面向对象在空引用的情况下完备了。如果你写了一个带有<code>Null</code>作为参数的对象，那么你传入的参数只能是<code>null</code>，或者指向<code>Null</code>的引用。</p>

<pre><code>scala&gt; def tryit(value: Null) {}
tryit: (value: Null)Unit

scala&gt; tryit("hey")
&lt;console&gt;:12: error: type mismatch;
 found   : String("hey")
 required: Null
       tryit("hey")
	     ^

scala&gt; val someRef: String = null
someRef: String = null

scala&gt; tryit(someRef)
&lt;console&gt;:13: error: type mismatch;
 found   : String
 required: Null
       tryit(someRef)
	     ^

scala&gt; tryit(null)

scala&gt; val nullRef: Null = null
nullRef: Null = null

scala&gt; tryit(nullRef)
</code></pre>

<p>第四行我们试图传入一个<code>String</code>，自然不能工作。第14行我们传入一个<code>null</code>引用，但是仍然不能工作，为什么呢？因为<code>null</code>引用指向的是<code>String</code>类型。它可能在运行时是<code>null</code>，但是在编译时类型检查却不认同，编译器认为他是个<code>String</code>。</p>

<h2 id="nil">Nil</h2>

<p><code>Nil</code>是一个继承<code>List[Nothing]</code>的对象。它就是一个空的列表，下面是一些使用实例：  <br />
	scala&gt; Nil
	res16: scala.collection.immutable.Nil.type = List()</p>

<pre><code>scala&gt; Nil.length
res17: Int = 0

scala&gt; "ABC":: Nil
res18: List[String] = List(ABC)

scala&gt; Nil :: Nil
res19: List[scala.collection.immutable.Nil.type] = List(List())
</code></pre>

<p>可以看出，<code>Nil</code>长度为0。它并不是一无所有，它是一个容器，一个列表，只是没有存放内容而已。</p>

<h2 id="nothing">Nothing</h2>

<p><code>Nothing</code>可能比较难理解。<code>Nothing</code>也是一个<code>Trait</code>，它继承自<code>Any</code>，而<code>Any</code>是整个Scala类型系统的根。<code>Nothing</code>是没有实例的，但它是任何对象的子类，他是<code>List</code>的子类，是<code>String</code>的子类，是<code>Int</code>的子类，是任何用户自定义类型的子类。  <br />
前面提到<code>Nil</code>是一个空的<code>List[Nothing]</code>。由于<code>Nothing</code>是任何类型的子类，那么<code>Nil</code>就可以当做是一个空的<code>String List</code>，空的<code>Int List</code>，甚至使<code>Any List</code>。<code>Nothing</code>比较适合用来定义基类容器。</p>

<pre><code>scala&gt; val emptyStringList: List[String] = List[Nothing]()
emptyStringList: List[String] = List()

scala&gt; val emptyIntList: List[Int] = List[Nothing]()
emptyIntList: List[Int] = List()

scala&gt; val emptyStringList: List[String] = List[Nothing]("abc")
&lt;console&gt;:10: error: type mismatch;
 found   : String("abc")
 required: Nothing
       val emptyStringList: List[String] = List[Nothing]("abc")
</code></pre>

<p>第一行，我们将一个<code>List[Nothing]</code>赋值给一个<code>List[String]</code>。一个<code>Nothing</code>是一个<code>String</code>，因此是正确的。第四行，我们将一个<code>List[Nothing]</code>赋值给一个<code>List[Int]</code>。一个<code>Nothing</code>是一个<code>Int</code>，因此是正确的。<code>Nothing</code>是任何类型的子类，但是上面的<code>List[Nothing]</code>都不包含任何成员。当我们创建一个包含一个<code>String</code>的<code>List[Nothing]</code>的<code>List</code>，并把它赋值给<code>List[String]</code>，会出现什么情况？它会失败，因为<code>Nothing</code>并不是任何类型的父类，并且也不存在<code>Nothing</code>的实例。任何<code>Nothing</code>的容器必然是空的，是<code>Nil</code>。  <br />
另一种<code>Nothing</code>的用法是作为不返回函数的返回值。因为<code>Nothing</code>没有任何实例，而函数的返回值必定是一个值，是一个对象，这样定义为<code>Nothing</code>为返回值的函数实际上不可能返回。</p>

<pre><code>scala&gt; def test():Nothing = { throw new IllegalArgumentException }
test: ()Nothing

scala&gt; test
java.lang.IllegalArgumentException
  at .test(&lt;console&gt;:10)
  ... 33 elided
</code></pre>

<h2 id="none">None</h2>

<p>写Java程序的时候，经常会碰到没有有意义的东西可以返回，我们返回<code>null</code>。但返回<code>null</code>有一些问题，调用方必须检查返回值，不然会有<code>NullPointerException</code>的异常。这逼迫我们去check函数的返回值。还有一种解决办法是使用异常，但增加try/catch块，并不是明智的选择。                     <br />
Scala内置一种解决办法。如果你想返回一个<code>String</code>，但可能有的时候得不到有意义的返回值，我们可以让函数返回<code>Option[String]</code>。</p>

<pre><code>scala&gt; def getAsStringMaybe(num: Int): Option[String] = {
     |   if (num &gt;= 0) Some("A positive number!")
     |   else None  //A number less than 0? Impossible!
     | }
getAsStringMaybe: (num: Int)Option[String]

scala&gt; def printResult(num: Int) = {
     |     getAsStringMaybe(num) match {
     |         case Some(str) =&gt; println(str)
     |         case None =&gt; println("No string!")
     | }
     | }
printResult: (num: Int)Unit

scala&gt; printResult(100)
A positive number!

scala&gt; printResult(-50)
No string!
</code></pre>

<p>函数<code>getAStringMaybe</code>返回<code>Option[String]</code>。<code>Option</code>是一个抽象类，它有两个子类：<code>Some</code>和<code>None</code>。因此，初始化一个<code>Option</code>有两种方法。<code>getAStringMaybe</code>返回的只可能是<code>Some[String]</code>或<code>None</code>。<code>Some</code>和<code>None</code>又是<code>Case Class</code>，可以直接用来做模式匹配，很容易用来处理返回值。 <br />
类似地，<code>Option[T]</code>作为返回值，意味着调用者可能会收到<code>Some[T]</code>或<code>None</code>。 <br />
其实<code>Option</code>作为返回值，并没有比返回<code>null</code>好多少。代码里面充满了<code>Option</code>和模式匹配的代码，也不优雅，所以对待<code>Option</code>还是慎重。</p>

<h2 id="unit">Unit</h2>

<p><code>Unit</code>跟java的<code>void</code>一样，表示函数没有返回值。</p>

<pre><code>scala&gt; def doThreeTimes(fn: (Int) =&gt; Unit) = {
     |     fn(1); fn(2);fn(3);
     | }
doThreeTimes: (fn: Int =&gt; Unit)Unit

scala&gt; doThreeTimes(println)
1
2
3

scala&gt; def specialPrint(num: Int) = {
     |     println("&gt;&gt;&gt;" + num + "&lt;&lt;&lt;")
     | }
specialPrint: (num: Int)Unit

scala&gt; doThreeTimes(specialPrint)
&gt;&gt;&gt;1&lt;&lt;&lt;
&gt;&gt;&gt;2&lt;&lt;&lt;
&gt;&gt;&gt;3&lt;&lt;&lt;
</code></pre>

<p>总的来看，Scala定义如此多的无，主要目的是为了保证它的类型系统的完整性，同时细化概念。到底好不好呢？下一个十年再下定论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Scala CHAPTER 2 Working with Data: Literals, Values,Variables, and Types]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-2-working-with-data-literals-values-variables-and-types/"/>
    <updated>2015-12-29T23:25:28+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-2-working-with-data-literals-values-variables-and-types</id>
    <content type="html"><![CDATA[<p>In this chapter we will cover the core data and variable types in Scala. Let’s start with the definitions of the terms <code>literal</code>, <code>value</code>, <code>variable</code>, and <code>type</code>:</p>

<ul>
  <li>A literal (or literal data) is data that appears directly in the source code, like the number <code>5</code>, the character <code>A</code>, and the text “<code>Hello, World.</code>”</li>
  <li>A value is an immutable, typed storage unit. A value can be assigned data when it is defined, but can never be reassigned.</li>
  <li>A variable is a mutable, typed storage unit. A variable can be assigned data when it is defined and can also be reassigned data at any time.</li>
  <li>A type is the kind of data you are working with, a definition or classification of data.</li>
</ul>

<p>All data in Scala corresponds to a specific type, and all Scala types are defined as classes with methods that operate on the data.       <br />
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#values" id="markdown-toc-values">Values</a>    <ul>
      <li><a href="#syntax-defining-a-value" id="markdown-toc-syntax-defining-a-value">Syntax: Defining a Value</a></li>
    </ul>
  </li>
  <li><a href="#variables" id="markdown-toc-variables">Variables</a>    <ul>
      <li><a href="#syntax-defining-a-variable" id="markdown-toc-syntax-defining-a-variable">Syntax: Defining a Variable</a></li>
    </ul>
  </li>
  <li><a href="#naming" id="markdown-toc-naming">Naming</a></li>
  <li><a href="#types" id="markdown-toc-types">Types</a>    <ul>
      <li><a href="#numeric-data-types" id="markdown-toc-numeric-data-types">Numeric Data Types</a></li>
      <li><a href="#literal-characters-are-case-insensitive" id="markdown-toc-literal-characters-are-case-insensitive">Literal Characters Are Case-Insensitive</a></li>
    </ul>
  </li>
  <li><a href="#strings" id="markdown-toc-strings">Strings</a>    <ul>
      <li><a href="#string-interpolation" id="markdown-toc-string-interpolation">String interpolation</a></li>
    </ul>
  </li>
  <li><a href="#regular-expressions" id="markdown-toc-regular-expressions">Regular expressions</a>    <ul>
      <li><a href="#table-2-3-regular-expression-operations" id="markdown-toc-table-2-3-regular-expression-operations">Table 2-3. Regular expression operations</a>        <ul>
          <li><a href="#syntax-capturing-values-with-regular-expressions" id="markdown-toc-syntax-capturing-values-with-regular-expressions">Syntax: Capturing Values with Regular Expressions</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#an-overview-of-scala-types" id="markdown-toc-an-overview-of-scala-types">An Overview of Scala Types</a>    <ul>
      <li><a href="#table-2-4-core-nonnumeric-types" id="markdown-toc-table-2-4-core-nonnumeric-types">Table 2-4. Core nonnumeric types</a>        <ul>
          <li><a href="#what-is-the-difference-between--and--" id="markdown-toc-what-is-the-difference-between--and--">What is the Difference Between &amp; and &amp;&amp; ?</a></li>
        </ul>
      </li>
      <li><a href="#type-operations" id="markdown-toc-type-operations">Type operations</a>        <ul>
          <li><a href="#table-2-5-common-type-operations" id="markdown-toc-table-2-5-common-type-operations">Table 2-5. Common type operations</a>            <ul>
              <li><a href="#avoid-asinstanceof" id="markdown-toc-avoid-asinstanceof">Avoid asInstanceOf</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#tuples" id="markdown-toc-tuples">Tuples</a>        <ul>
          <li><a href="#syntax-create-a-tuple" id="markdown-toc-syntax-create-a-tuple">Syntax: Create a Tuple</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<p>The data stored in values and variables in Scala will get automatically deallocated by the Java Virtual Machine’s garbage collection when they are no longer used. There is no ability, or need, to deallocate them manually.</p>

<p>Let’s try exercising these terms by working with data in the Scala REPL. Scala values are defined with the syntax <code>val &lt;name&gt;: &lt;type&gt; = &lt;literal&gt;</code>, so we will create a value with the name <code>x</code>, type <code>Int</code>(short for “<code>integer</code>”), and assigned it the literal number <code>5</code>:</p>

<pre><code>scala&gt; val x: Int = 5
x: Int = 5
</code></pre>

<p>What happened here? The REPL (again, a Read-Evaluate-Print-Loop shell) read the value definition, evaluated it, and reprinted it as a confirmation. The new value, named <code>x</code>, is now defined and available to use. So let’s use it:</p>

<pre><code>scala&gt; x
res3: Int = 5

scala&gt; x * 2
res4: Int = 10

scala&gt; x * 2
res5: Int = 10

scala&gt; x / 5
res6: Int = 1
</code></pre>

<p>Each of these three input lines are valid Scala syntax and return an integer value. In each case, because a value is returned, the REPL repeats the value and its type and also assigns a unique, sequentially named value starting with <code>res0</code> (short for “result”). You can choose to make use of these “result” values just like any value you explicitly define:</p>

<pre><code>scala&gt; res3 * res4
res7: Int = 50
</code></pre>

<p>Here the values <code>res3</code> and <code>res4</code> are multiplied, resulting in the value <code>50</code> being returned and stored in the new value named <code>res7</code>.  <br />
Let’s try working with variables now. Variables, which unlike values are mutable and can be reassigned new values, are defined with the syntax <code>var &lt;name&gt;: &lt;type&gt; = &lt;literal&gt;</code>.</p>

<pre><code>scala&gt; var a: Double = 2.72
a: Double = 2.72

scala&gt; a = 355.0 / 133.0
a: Double = 2.669172932330827

scala&gt; a = 5
a: Double = 5.0
</code></pre>

<p>In this example we defined the variable a to have the type <code>Double</code>, a double-precision floating-point number. And then, because it is a variable, we reassigned it to a different value.</p>

<p>This has been a short introduction to using values, variables, types, and literals in Scala.In the rest of this chapter we will cover each of these subject areas in depth.</p>

<h2 id="values">Values</h2>

<p>Values are immutable, typed storage units, and by convention are the default method for storing data. You can define a new value using the <code>val</code> keyword.</p>

<h3 id="syntax-defining-a-value">Syntax: Defining a Value</h3>

<pre><code>val &lt;identifier&gt;[: &lt;type&gt;] = &lt;data&gt;
</code></pre>

<p>Values require both a name and assigned data, but they do not require an explicit type. If the type is not specified (i.e., the “<code>: &lt;type&gt;</code>” syntax is not included), the Scala compiler will infer the type based on the assigned data.</p>

<p>Here are some examples of defining values with their type in the Scala REPL:</p>

<pre><code>scala&gt; val x:Int = 20
x: Int = 20

scala&gt; val greeting: String = "Hello, World"
greeting: String = Hello, World

scala&gt; val atSymbol: Char = '@'
atSymbol: Char = @
</code></pre>

<p>You may have noticed from the syntax diagram that specifying the type in value definitions is optional. In situations where it is possible to deduce the type of the value based on its assignment (for example, the literal <code>20</code> in the first example is obviously an integer),you can leave off the type from a value definition. The Scala compiler will then discern the type of the value from its assignment, a process known as type inference. <strong>Values defined without a type are not typeless; they are assigned the proper type just as if the type had been included in the definition.</strong></p>

<p>Let’s try the examples again without specifying their types:</p>

<pre><code>scala&gt; val x = 20
x: Int = 20

scala&gt; val greeting = "Hello, World"
greeting: String = Hello, World

scala&gt; val atSymbol = '@'
atSymbol: Char = @
</code></pre>

<p>In this example the values end up having the same types (<code>Int</code>, <code>String</code>, and <code>Char</code>) as they did when the types were explicitly stated. The Scala compiler, via the REPL, was able to deduce that the literal <code>20</code> corresponds to the type <code>Int</code>, the literal “<code>Hello, World</code>” to the type <code>String</code>, and the literal <code>@</code> to the type <code>Char</code>.</p>

<p>Using Scala’s type inference is a helpful shortcut when writing code because it removes the need to explicitly write the type of a value. As a guideline it should only be used when it does not reduce the readability of your code. In the case that someone reading your code would not be able to figure out what the type of the value is, it would be better to include the explicit type in the value definition.</p>

<p>Although type inference will deduce the correct type to use to store data, it will not override an explicit type that you set. If you define a value with a type that is incompatible with the initial value you will get a compilation error:</p>

<pre><code>scala&gt; val x: Int = "Hello"
&lt;console&gt;:10: error: type mismatch;
 found   : String("Hello")
 required: Int
       val x: Int = "Hello"
</code></pre>

<p>The error here affirms that an <code>Int</code> type cannot be used to store a <code>String</code>.</p>

<h2 id="variables">Variables</h2>

<p>In computer science the term variable typically refers to a unique identifier corresponding to an allocated or reserved memory space, into which values can be stored and from which values can be retrieved. As long as the memory space is reserved, it can be assigned new values over and over again. Thus, the contents of the memory space are dynamic, or variable.</p>

<p>In most languages, such as C, Java, PHP, Python, and Ruby, this is the typical pattern for working with named, assignable memory storage. Variables are dynamic, mutable,and reassignable (with the exception of those defined with special restrictions such as Java’s <code>final</code> keyword).</p>

<p>In Scala, values are preferred over variables by convention, due to the stability and predictability they bring to source code. When you define a value you can be assured that it will retain the same value regardless of any other code that may access it. Reading and debugging code is easier when a value assigned at the beginning of a code segment is unchanged through the end of the code segment. Finally, when working with data that may be available for the life span of an application, or accessible from concurrent or multithreaded code, an immutable value will be more stable and less prone to errors than mutable data that may be modified at unexpected times.                          <br />
The example code and exercises in this book prefer the use of values over variables.However, in those places where variables are more suitable, such as local variables that store temporary data or accumulate values in loops, variables will certainly be used.  <br />
Now that the preference for values over variables has been explained in detail, we can put that aside and cover how to use variables in Scala.  <br />
The <code>var</code> keyword is used to define a variable with a given name, type, and assignment.</p>

<h3 id="syntax-defining-a-variable">Syntax: Defining a Variable</h3>

<pre><code>var &lt;identifier&gt;[: &lt;type&gt;] = &lt;data&gt;
</code></pre>

<p>Like values, variables can be defined with or without an explicit type. If no type is specified the Scala compiler will use type inference to determine the correct type to assign to your variable. Unlike values, variables can be reassigned new data at any time.</p>

<p>Here is an example of defining a variable and then reassigning it, in this case to the product of itself and another number:</p>

<pre><code>scala&gt; var x = 5
x: Int = 5

scala&gt; x = x * 4
x: Int = 20
</code></pre>

<p>Although a variable can be reassigned, its designated type cannot, and so a variable cannot be reassigned data that has an incompatible type. For example, defining a variable of type <code>Int</code> and then assigning it a <code>String</code> value will result in a compiler error:   <br />
跟在命令行中可以重复定义变量是不一样的:</p>

<pre><code>scala&gt; var x = "Hello, world"
x: String = Hello, world

scala&gt; var x = 5
x: Int = 5
</code></pre>

<p>只有在命令行中才可以这样做</p>

<pre><code>cala&gt; var x = 5
x: Int = 5

scala&gt; x = "what's up?"
&lt;console&gt;:11: error: type mismatch;
 found   : String("what\'s up?")
 required: Int
       x = "what's up?"
</code></pre>

<p>However, defining a variable of type <code>Double</code> and assigning it an <code>Int</code> value will work because <code>Int</code> numbers can be converted to <code>Double</code> numbers automatically:</p>

<pre><code>scala&gt; var y = 1.5
y: Double = 1.5

scala&gt; y = 42
y: Double = 42.0
</code></pre>

<h2 id="naming">Naming</h2>

<p>Scala names can use letters, numbers, and a range of special operator characters. This makes it possible to use standard mathematical operators (e.g., <code>*</code> and <code>:+</code>) and constants (e.g., <code>π</code> and <code>φ</code>) in place of longer names to make the code more expressive.                       <br />
The Scala Language Specification defines these operator characters as “all other characters in \u0020-007F<code> and Unicode categories Sm [Symbol/Math] ... except parentheses (</code>[]`) and periods.” Square brackets (referred to in the text as parentheses) are reserved for use in type parameterization, while periods are reserved for access to the fields and methods of objects (instantiated types).</p>

<p>Here are the rules for combining letters, numbers, and characters into valid identifiers  in Scala:</p>

<ul>
  <li>A letter followed by zero or more letters and digits.</li>
  <li>A letter followed by zero or more letters and digits, then an underscore (<code>_</code>), and then one or more of either letters and digits or operator characters.</li>
  <li>One or more operator characters.</li>
  <li>One or more of any character except a backquote, all enclosed in a pair of backquotes.</li>
</ul>

<p>Names enclosed in backquotes(就是这个``符号) can, unlike the other names, be reserved keywords in Scala such as <code>true</code>, <code>while</code>, <code>=</code>, and <code>var</code>.</p>

<p>Let’s try out some of these naming rules in the REPL:</p>

<pre><code>scala&gt; val π = 3.14159
π: Double = 3.14159
</code></pre>

<p>The special character “π” is a valid Scala identifier.</p>

<pre><code>scala&gt; val $ = "USD currency symbol"
$: String = USD currency symbol




scala&gt; val o_O = "Hmm"
o_O: String = Hmm

scala&gt; val 50cent = "$0.50"
&lt;console&gt;:1: error: Invalid literal number
val 50cent = "$0.50"
    ^
</code></pre>

<p>The value name “<code>50cent</code>” is invalid because names cannot start with numbers.In this case the compiler started parsing the name as a literal number and ran into problems at the letter “<code>c</code>”.</p>

<pre><code>scala&gt; val a.b = 25
&lt;console&gt;:11: error: value b is not a member of Int
       val a.b = 25
	     ^ The value name “a.b” is invalid because a period isn’t an operator character.                

scala&gt; val `a.b` = 4
a.b: Int = 4
</code></pre>

<p>Rewriting this value with backquotes fixes the problem, although the aesthetics of using backquotes isn’t that great.</p>

<p>Value and variable names, by convention, should start with a lowercase letter and then capitalize additional words. This is popularly known as camel case, and though not required it is recommended for all Scala developers. This helps to distinguish them from types and classes which (also by convention, not by rule) follow camel case but start with an uppercase letter.</p>

<h2 id="types">Types</h2>

<p>Scala has both numeric (e.g., <code>Int</code> and <code>Double</code>) and nonnumeric types (e.g., <code>String</code>) that can be used to define values and variables. These core types are the building blocks for all other types including objects and collections, and are themselves objects that have methods and operators that act on their data.</p>

<p>Unlike Java and C there is no concept of a primitive type in Scala. While the Java Virtual Machine supports the primitive integer type <code>int</code> and the integer class <code>Integer</code>, Scala only supports its own integer class, <code>Int</code>.</p>

<h3 id="numeric-data-types">Numeric Data Types</h3>

<p>Table 2-1 displays Scala’s numeric data types.</p>

<p>Table 2-1. Core numeric types</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: center">Size</th>
      <th style="text-align: center">Min</th>
      <th style="text-align: center">Max</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Byte</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">1 byte</td>
      <td style="text-align: center">–127</td>
      <td style="text-align: center">128</td>
    </tr>
    <tr>
      <td style="text-align: center">Short</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">2 bytes</td>
      <td style="text-align: center">–32768</td>
      <td style="text-align: center">32767</td>
    </tr>
    <tr>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">–2^31</td>
      <td style="text-align: center">2^31–1</td>
    </tr>
    <tr>
      <td style="text-align: center">Long</td>
      <td style="text-align: center">Signed integer</td>
      <td style="text-align: center">8 bytes</td>
      <td style="text-align: center">–2^63</td>
      <td style="text-align: center">2^63–1</td>
    </tr>
    <tr>
      <td style="text-align: center">Float</td>
      <td style="text-align: center">Signed floating point</td>
      <td style="text-align: center">4 bytes</td>
      <td style="text-align: center">n/a</td>
      <td style="text-align: center">n/a</td>
    </tr>
    <tr>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">Signed floating point</td>
      <td style="text-align: center">8 bytes</td>
      <td style="text-align: center">n/a</td>
      <td style="text-align: center">n/a</td>
    </tr>
  </tbody>
</table>

<p>See the API documentation for <code>java.lang.Float</code> and <code>java.lang.Double</code> for a description of the calculated maximum and minimum values for these floating-point numbers.</p>

<p>Scala supports the ability to automatically convert numbers from one type to another based on the rank of the type. The numeric types in Table 2-1 are sorted by their automatic conversion rank, where the Byte type is the lowest and can be converted to any other type.</p>

<p>Let’s try this out by creating values of different types and automatically converting them to higher-ranked types:</p>

<pre><code>scala&gt; val b: Byte = 10
b: Byte = 10

scala&gt; val s: Short = b
s: Short = 10

scala&gt; val d: Double = s
d: Double = 10.0
</code></pre>

<p>The <code>b</code> and <code>s</code> values here were assigned to new values that had a higher rank, and so were automatically converted (or “upconverted” as some say) to the higher ranks.</p>

<p>Java developers will recognize the names of these types, which are wrappers around the core JVM types of the same names (except the JVM’s <code>Integer</code> is Scala’s <code>Int</code>). Wrapping JVM types ensures that Scala and Java are interopable, and that Scala can make use of every Java library.</p>

<p><strong>Scala does not allow automatic conversion from higher ranked types to lower ranked types.</strong> This makes sense, because you could otherwise lose data if you convert to a type with less storage. Here is an example of trying to automatically convert a higher ranked type to a lower ranked type and the ensuing error:</p>

<pre><code>scala&gt; val l: Long = 20
l: Long = 20

scala&gt; val i: Int = l
&lt;console&gt;:11: error: type mismatch;
 found   : Long
 required: Int
       val i: Int = l
		    ^
</code></pre>

<p>You can choose to manually convert between types using the <code>toType</code> methods available on all numeric types. Although this makes it possible to lose data by converting to a lesser ranked type, it is useful when you know that the data is compatible with the lower ranked type.</p>

<p>For example, here is a <code>Long</code> value that can be safely converted to type <code>Int</code> using the <code>toInt</code> method, because its data is within the storage bounds of an <code>Int</code>:</p>

<pre><code>scala&gt; val l: Long = 20
l: Long = 20

scala&gt; val i: Int = l.toInt
i: Int = 20
</code></pre>

<p>我这时候就想：如果是超过了低精度类型的数呢:</p>

<pre><code>scala&gt; val l: Long = 999999999999999999l
l: Long = 999999999999999999

scala&gt; val i: Int = l.toInt
i: Int = -1486618625
</code></pre>

<p>Scala并没有报错，是可以的</p>

<p>An alternative to using explicit types is to specify the type of your literal data directly,using Scala’s notation for literal types. See Table 2-2 for the full list of notations for specifying the types of literals.</p>

<p>Table 2-2. Numeric literals</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Literal</th>
      <th style="text-align: center">Type</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">Unadorned（adj. 朴素的；未装饰的） integer literals are <code>Int</code> by default</td>
    </tr>
    <tr>
      <td style="text-align: center">0x0f</td>
      <td style="text-align: center">Int</td>
      <td style="text-align: center">The “0x” prefix denotes hexadecimal notation</td>
    </tr>
    <tr>
      <td style="text-align: center">5l</td>
      <td style="text-align: center">Long</td>
      <td style="text-align: center">The “<code>l</code>” suffix denotes a <code>Long</code> type</td>
    </tr>
    <tr>
      <td style="text-align: center">5.0</td>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">Unadorned decimal literals are <code>Double</code> by default</td>
    </tr>
    <tr>
      <td style="text-align: center">5f</td>
      <td style="text-align: center">Float</td>
      <td style="text-align: center">The “<code>f</code>” suffix denotes a <code>Float</code> type</td>
    </tr>
    <tr>
      <td style="text-align: center">5d</td>
      <td style="text-align: center">Double</td>
      <td style="text-align: center">The “<code>d</code> suffix denotes a <code>Double</code> type</td>
    </tr>
  </tbody>
</table>

<h3 id="literal-characters-are-case-insensitive">Literal Characters Are Case-Insensitive</h3>

<p>You can use either lowercase or uppercase letters in Scala’s literal types.The literal number <code>5L</code> is the same as the literal number <code>5l</code>.</p>

<p>Let’s try out these literals by assigning them to new values without stating the type. The Scala REPL will use type inference to calculate the appropriate types for each value:</p>

<pre><code>scala&gt; val anInt = 5
anInt: Int = 5

scala&gt; val yellowRgb = 0xffff00
yellowRgb: Int = 16776960

scala&gt; val id = 100l
id: Long = 100

scala&gt; val pi = 3.1416
pi: Double = 3.1416
</code></pre>

<h2 id="strings">Strings</h2>

<p>The <code>String</code> type represents “strings” of text, one of the most common core types in any programming language. Scala’s <code>String</code> is built on Java’s <code>String</code> and adds unique features like multiline literals and string interpolation(n. 插入；篡改；添写).</p>

<p>Write <code>String</code> literals using double quotes, with special characters escaped with backslashes:</p>

<pre><code>scala&gt; val hello = "Hello There"
hello: String = Hello There

scala&gt; val signature = "With Regards, \nYour friend"
signature: String =
With Regards,
Your friend
</code></pre>

<p>Like numeric types, the <code>String</code> type supports the use of math operators. For example,use the equals operator (<code>==</code>) to compare two <code>String</code> values. Unlike Java, the equals operator (<code>==</code>) checks for <code>true</code> equality, not object reference equality:</p>

<pre><code>scala&gt; val greeting = "Hello, " + "World"
greeting: String = Hello, World

scala&gt; val matched = (greeting == "Hello, World")
matched: Boolean = true

scala&gt; val theme = "Na " * 16 + "Batman!" //what do you expect this to print
theme: String = Na Na Na Na Na Na Na Na Na Na Na Na Na Na Na Na Batman!
</code></pre>

<p>A multiline <code>String</code> can be created using triple-quotes. Multiline strings are literal, and so do not recognize the use of backslashes as the start of special characters:</p>

<pre><code>scala&gt; val greeting = """She suggested reformatting the file
     | by replacing tabs (\t) with newlines (\n);
     | "Why do that?", he asked."""
greeting: String =
She suggested reformatting the file
by replacing tabs (\t) with newlines (\n);
"Why do that?", he asked.
</code></pre>

<h3 id="string-interpolation">String interpolation</h3>

<p>Building a <code>String</code> based on other values is reasonably easy to do with string addition.Here is a <code>String</code> built by adding text before and after the <code>Float</code> value:</p>

<pre><code>scala&gt; val approx = 355/113f
approx: Float = 3.141593

scala&gt; println("Pi, using 355/113, is about " + approx + ".")
Pi, using 355/113, is about 3.141593.
</code></pre>

<p>A more direct way to combine your values or variables inside a <code>String</code> is with string interpolation, a special mode where external value and variable names are recognized and resolved. The Scala notation for string interpolation is an “<code>s</code>” prefix added before the first double quote of the string. Then dollar sign operators (<code>$</code>) (with optional braces) can be used to note references to external data.(抄php的) <br />
Here is the example again using string interpolation:</p>

<pre><code>scala&gt; println(s"Pi, using 355/113, is about $approx.")
Pi, using 355/113, is about 3.141593.
</code></pre>

<p>You will need the optional braces if you have any nonword characters in your reference (such as a calculation), or if your reference can’t be distinguished from the surrounding text:</p>

<pre><code>scala&gt; val item = "apple"
item: String = apple

scala&gt; s"How do you like tem ${item}s"
res1: String = How do you like tem apples

scala&gt; s"Fish n chips n vinegar,${"papper " * 3}salt"
res2: String = Fish n chips n vinegar,papper papper papper salt
</code></pre>

<p>An alternate format for string interpolation uses <code>printf</code> notation, very useful when you want to control the data formatting such as the character count or display of decimal values. To use <code>printf</code> notation change the prefix to an “<code>f</code>” and follow the end of the reference immediately with the <code>printf</code> notation: <br />
If you are unfamiliar with <code>printf</code> there are numerous online references for the format, including the official Javadoc for <code>java.util.Formatter</code>, the underlying engine used by Scala to format these strings.</p>

<pre><code>scala&gt; val item = "apple"
item: String = apple

scala&gt; f"I wrote a new $item%.3s today"
res4: String = I wrote a new app today

scala&gt; f"Enjoying this $item ${355/113.0}%.5f times today"
res5: String = Enjoying this apple 3.14159 times today
</code></pre>

<p>These <code>printf</code> notations make the references a little harder to read than in the previous examples, but do provide essential control over the output.</p>

<p>Now that we have learned how to control data output with strings, let’s find out how to do the opposite with regular expressions.</p>

<h2 id="regular-expressions">Regular expressions</h2>

<p>A regular expression is a string of characters and punctuation that represents a search pattern. Popularized by Perl and command-line utilities like Grep, regular expressions are a standard feature in the libraries of most programming languages including Scala.</p>

<p>The format for Scala’s regular expressions is based on the Java class <code>java.util.regex.Pattern</code>. I recommend reading the Javadoc (the Java API documentation) for <code>java.util.regex.Pattern</code> if you are unfamiliar with this type, because Java’s (and thus Scala’s) regular expressions may be different from the format you have used with other languages and tools.</p>

<p>The <code>String</code> type provides a number of built-in operations that support regular expressions. Table 2-3 displays a selection of these operations.</p>

<h3 id="table-2-3-regular-expression-operations">Table 2-3. Regular expression operations</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Example</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">matches</td>
      <td style="text-align: center">“Froggy went a’ courting” matches “.* courting”</td>
      <td style="text-align: center">Returns true if the regular expression matches the entire string.</td>
    </tr>
    <tr>
      <td style="text-align: center">Description</td>
      <td style="text-align: center">“milk, tea, muck” replaceAll (“m[^ ]+k”, “coffee”)</td>
      <td style="text-align: center">Replaces all matches with replacement text.</td>
    </tr>
    <tr>
      <td style="text-align: center">replaceFirst</td>
      <td style="text-align: center">“milk, tea, muck” replaceFirst (“m[^ ]+k”, “coffee”)</td>
      <td style="text-align: center">Replaces the first match with replacement text.</td>
    </tr>
  </tbody>
</table>

<p>For more advanced handling of regular expressions, convert a string to a regular expression type by invoking its <code>r</code> operator. This will return a Regex instance that can handle additional search and replace operations as well as capture group support. A capture group makes it possible to select items in a given string and convert them to local values based on the regular expression pattern. The pattern must include at least one capture group defined by parentheses, and the input must include at least one of the captured patterns to return the value.</p>

<h4 id="syntax-capturing-values-with-regular-expressions">Syntax: Capturing Values with Regular Expressions</h4>

<pre><code>val &lt;Regex value&gt;(&lt;identifier&gt;) = &lt;input string&gt;
</code></pre>

<p>Let’s try this out by capturing the numeric value from the output of the previous example (see “String interpolation” on page 18). We’ll use multiline strings to store our regular expression pattern, because they are literal and allow us to write a backslash without a second, escaping backslash:</p>

<pre><code>scala&gt; val input = "Enjoying this apple 3.14159 times today"
input: String = Enjoying this apple 3.14159 times today

scala&gt; val pattern = """.* apple ([\d.]+) times .*""".r
</code></pre>

<p>The capture group is the series of digits and a period between the words <code>apple</code> and <code>times</code>.</p>

<pre><code>pattern: scala.util.matching.Regex = .* apple ([\d.]+) times .*
</code></pre>

<p>The full regular expression type is <code>scala.util.matching.Regex</code>, or just <code>util.matching.Regex</code>.</p>

<pre><code>scala&gt; val pattern(amountText) = input
amountText: String = 3.14159
</code></pre>

<p>The format is admittedly a bit odd. The name of the new value containing the capture group match, <code>amountText</code>, does not directly follow the <code>val</code> identifier.</p>

<pre><code>scala&gt; val amount = amountText.toDouble
amount: Double = 3.14159
</code></pre>

<p>After converting the amount in text form to a <code>Double</code> we have our numeric value.</p>

<p>Regular expressions serve as a compact and efficient means to process text, with operations such as matching, replacing, and capturing. If you are still new to regular expressions, it is worth investing time to study them because they are widely applicable in modern software development.</p>

<pre><code>scala&gt; val pattern(amountText) = input
scala.MatchError: tt (of class java.lang.String)
  ... 33 elided
</code></pre>

<p>如果没有匹配项就会报错</p>

<h2 id="an-overview-of-scala-types">An Overview of Scala Types</h2>

<p>In this section we will move on from numbers and strings to a broader look at the range of core types. All of Scala’s types, from numbers to strings to collections, exist as part of a type hierarchy. Every class that you define in Scala will also belong to this hierarchy automatically.</p>

<p>Figure 2-1 shows the hierarchy of Scala’s core (numeric and nonnumeric) types.    <br />
<img src="http://scalajiaocheng.github.io/images/scala/Figure 2-1. The Scala type hierarchy.png" alt="Figure 2-1. The Scala type hierarchy" /></p>

<p>The open-headed arrows in the diagram indicate supertypes, a common notation in object-oriented diagrams. The multiple-arrow types at the bottom indicate that they are subtypes of every type in the system, including classes you define on your own.  <br />
In Table 2-4 you can see a full listing of the specific types mentioned in this diagram, followed by more complete descriptions.</p>

<h3 id="table-2-4-core-nonnumeric-types">Table 2-4. Core nonnumeric types</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Description</th>
      <th style="text-align: center">Instantiable</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Any</td>
      <td style="text-align: center">The root of all types in Scala</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">AnyVal</td>
      <td style="text-align: center">The root of all value types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">AnyRef</td>
      <td style="text-align: center">The root of all reference (nonvalue) types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Nothing</td>
      <td style="text-align: center">The subclass of all types</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Null</td>
      <td style="text-align: center">The subclass of all AnyRef types signifying a null value</td>
      <td style="text-align: center">No</td>
    </tr>
    <tr>
      <td style="text-align: center">Char</td>
      <td style="text-align: center">Unicode character</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">Boolean</td>
      <td style="text-align: center">true or false</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">String</td>
      <td style="text-align: center">A string of characters (i.e., text)</td>
      <td style="text-align: center">Yes</td>
    </tr>
    <tr>
      <td style="text-align: center">Unit</td>
      <td style="text-align: center">Denotes the lack of a value</td>
      <td style="text-align: center">No</td>
    </tr>
  </tbody>
</table>

<p>The <code>Any</code>, <code>AnyVal</code>, and <code>AnyRef</code> types are the root of Scala’s type hierarchy. <code>Any</code> is the absolute root, and all other types descend from its two children, <code>AnyVal</code> and <code>AnyRef</code>.The types that extend <code>AnyVal</code> are known as value types because they are the core values used to represent data. They include all of the numeric types we have covered plus <code>Char</code>,<code>Boolean</code>, and <code>Unit</code>. <code>AnyVal</code> types are accessed just like other types but may be allocated at runtime either on the heap as objects or locally on the stack as a JVM primitive value.All other types have <code>AnyRef</code> as their root and are only ever allocated on the heap as objects. The term “<code>Ref</code>“ in “<code>AnyRef</code> ” indicates they they are reference types that are accessed via a memory reference.</p>

<p>At the bottom of the Scala type hierarchy are the <code>Nothing</code> and <code>Null</code> types. <code>Nothing</code> is a subtype of every other type and exists to provide a compatible return type for operations that significantly affect a program’s flow. For example, the <code>return</code> keyword, which exits a function early with a return value, has a return type of <code>Nothing</code> so it can be used in the middle of initializing a value and not affect the type of that value. <code>Nothing</code> is only used as a type, because it cannot be instantiated.</p>

<p>The other bottom type is <code>Null</code>, a subtype of all <code>AnyRef</code> types that exists to provide a type for the keyword <code>null</code>. A <code>String</code> variable, for example, can be assigned <code>null</code> at any time,such that the variable does not point to any string instance in memory. This assignment of <code>null</code> to a variable declared as type <code>String</code> is acceptable because <code>null</code> is a compatible type for <code>String</code>. Defining a type for <code>null</code> is an example of how Scala’s syntax prefers the use of real types and instances to reserved keywords.      <br />
<code>Char</code> is the only type that could also appear in “Numeric Data Types” on page 15. As the basis of the <code>String</code> type it contains a single character and so is sometimes considered to be a unit of text. Essentially it is a scalar type that can be converted to and from other numbers.    <br />
<code>Char</code> literals are written with single quotes, distinguishing them from <code>String</code> literals,which are written with double quotes. If you’re familiar with the ASCII character numbering system, this example should be obvious:</p>

<pre><code>scala&gt; val c = 'A'
c: Char = A

scala&gt; val i: Int = c
i: Int = 65

scala&gt; val t: Char = 116
t: Char = t
</code></pre>

<p>The <code>Boolean</code> type is limited to the values <code>true</code> and <code>false</code>. In addition to using <code>true</code> and <code>false</code>, you can also obtain <code>Boolean</code> values from comparison and <code>Boolean</code> logic operators:</p>

<pre><code>scala&gt; val isTrue = !true
isTrue: Boolean = false

scala&gt; val isFalse = !true
isFalse: Boolean = false

scala&gt; val unequal = (5 != 6)
unequal: Boolean = true

scala&gt; val isLess = (5 &lt; 6)
isLess: Boolean = true

scala&gt; val unequalAndLess = unequal &amp; isLess
unequalAndLess: Boolean = true

scala&gt; val definitelyFalse = false &amp;&amp; unequal
definitelyFalse: Boolean = false
</code></pre>

<h4 id="what-is-the-difference-between--and--">What is the Difference Between &amp; and &amp;&amp; ?</h4>

<p>The <code>Boolean</code> comparison operators <code>&amp;&amp;</code> and <code>||</code> are lazy in that they will not bother evaluating the second argument if the first argument is sufficient. The operators <code>&amp;</code> and <code>|</code> will always check both arguments  <br />
Unlike many dynamic languages, Scala does not support automatic conversion of other types to <code>Booleans</code>. A nonnull string cannot be evaluated as <code>true</code>, and the number zero does not equal <code>false</code>. If you need to evaluate a value’s state to a <code>Boolean</code>, use an explicit comparison:</p>

<pre><code>scala&gt; val zero = 0
zero: Int = 0

scala&gt; val isValid = zero &gt; 0
isValid: Boolean = false
</code></pre>

<p>The <code>Unit</code> type is unlike the other core types here (numeric and nonnumeric) in that instead of denoting a type of data it denotes the lack of data. In a way it is similar to the <code>void</code> keyword used in Java and C, which is used to define a function that doesn’t return data. The <code>Unit</code> type is similarly used in Scala as the return type for functions or expressions that don’t return anything. For example, the common <code>println</code> function could be said to return a <code>Unit</code> type because it returns nothing.  <br />
The <code>Unit</code> literal is an empty pair of parentheses, <code>()</code>, which if you consider it is a fine representation of not having a value. If you want you can define a value or variable with the <code>Unit</code> type, but again its common usage is for defining functions and expressions:</p>

<pre><code>scala&gt; val nada = ()
nada: Unit = ()
</code></pre>

<p>Now that we have covered the core types, let’s have a look at the operations they all have in common.</p>

<h3 id="type-operations">Type operations</h3>

<p>Table 2-5 displays the operations available on all types in Scala. The <code>toString</code> and <code>hashCode</code> methods are required on all JVM instances.</p>

<h4 id="table-2-5-common-type-operations">Table 2-5. Common type operations</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Name</th>
      <th style="text-align: center">Example</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">asInstanceOf[<type>]</type></td>
      <td style="text-align: center">5.asInstanceOf[Long]</td>
      <td style="text-align: center">Converts the value to a value of the desired type.</td>
    </tr>
    <tr>
      <td style="text-align: center">getClass</td>
      <td style="text-align: center">(7.0 / 5).getClass</td>
      <td style="text-align: center">Returns the type (i.e., the class) of a value.</td>
    </tr>
    <tr>
      <td style="text-align: center">isInstanceOf</td>
      <td style="text-align: center">(5.0).isInstanceOf[Float]</td>
      <td style="text-align: center">Returns true if the value has the given type.</td>
    </tr>
    <tr>
      <td style="text-align: center">hashCode</td>
      <td style="text-align: center">“A”.hashCode</td>
      <td style="text-align: center">Returns the hash code of the value, useful for hash-based collections.</td>
    </tr>
    <tr>
      <td style="text-align: center">to<type></type></td>
      <td style="text-align: center">20.toByte; 47.toFloat</td>
      <td style="text-align: center">Conversion functions to convert a value to a compatible value.</td>
    </tr>
    <tr>
      <td style="text-align: center">toString</td>
      <td style="text-align: center">(3.0 / 4.0).toString</td>
      <td style="text-align: center">Renders the value to a String.</td>
    </tr>
  </tbody>
</table>

<h5 id="avoid-asinstanceof">Avoid asInstanceOf</h5>

<p>The <code>asInstanceOf</code> operation will cause an error if the value cannot be converted to the requested type. To avoid runtime errors with this operation, prefer the <code>to&lt;type&gt;</code> typed conversion operations when possible.</p>

<p>The types we have covered so far in this chapter are all (with the possible exception of <code>String</code>) scalar values, which represent a single element (or, of course with <code>Unit</code>, the lack of any element). As a complement to these scalar values, we will finish the chapter with the <code>Tuple</code> type, which can collect two or more of these values into a new,ordered element.</p>

<h3 id="tuples">Tuples</h3>

<p>A tuple is an ordered container of two or more values, all of which may have different types. You may be familiar with this term from working with relational databases, where a single row of a table is considered its own tuple. Tuples can be useful when you need to logically group values, representing them as a coherent unit. Unlike lists and arrays, however, there is no way to iterate through elements in a tuple. Its purpose is only as a container for more than one value.</p>

<p>You can create a tuple by writing your values separated by a comma and surrounded by a pair of parentheses.</p>

<h4 id="syntax-create-a-tuple">Syntax: Create a Tuple</h4>

<pre><code>( &lt;value 1&gt;, &lt;value 2&gt;[, &lt;value 3&gt;...] )
</code></pre>

<p>For example, here is a tuple containing <code>Int</code>, <code>String</code>, and <code>Boolean</code> values:</p>

<pre><code>scala&gt; val info = (5, "Korben", true)
ifno: (Int, String, Boolean) = (5,Korben,true)
</code></pre>

<p>You can access an individual element from a tuple by its 1-based index (e.g., where the first element is 1, second is 2, etc.):</p>

<pre><code>scala&gt; val name = info._2
name: String = Korben
</code></pre>

<p>An alternate form of creating a 2-sized tuple is with the relation operator (<code>-&gt;</code>). This is a popular shortcut for representing key-value pairs in tuples:</p>

<pre><code>scala&gt; val red = "red" -&gt; "oxff0000"
red: (String, String) = (red,oxff0000)

scala&gt; val reversed = red._2 -&gt; red._1
reversed: (String, String) = (oxff0000,red)
</code></pre>

<p>Tuples provide a generic means to structure data, and are useful when you need to group discrete elements for handling.</p>

<h2 id="summary">Summary</h2>

<p>This may be a challenging chapter to see through to the end, because you had to read all about types and data without learning how to do real programming in Scala yet. I’m glad you did.</p>

<p>What was the oddest or most-unexpected part of this chapter? The use of keywords to announce value and variable definition? The reversed manner (if you’re coming from Java) of defining a variable’s name before its type? The idea that much of your code can use fixed, nonreassignable values instead of (variable) variables?</p>

<p>If these ideas were hard to take, the good news is that, as you gain experience in Scala developemnt, they will become quite normal. Eventually they may even seem to be obvious choices for a well-designed functional programming language.</p>

<p>At this point you should know how to define your own values and variables, although we haven’t yet learned where to come up with useful data to store in them. In the next chapter you will study ways to derive and calculate this data using logical structures known as expressions.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learning Scala CHAPTER 1 Getting Started with the ScalableLanguage]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-1-getting-started-with-the-scalablelanguage/"/>
    <updated>2015-12-29T22:04:10+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2015/12/29/learning-scala-chapter-1-getting-started-with-the-scalablelanguage</id>
    <content type="html"><![CDATA[<p>The Scala programming language has a wonderfully continental(adj. 大陆的；大陆性的) ring to its name, as befits its origins at the École polytechnique fédérale de Lausanne (EPFL) in Lausanne,Switzerland. The Scala logo represents a circular stairway, which may lead you to believe its origin is the term <strong>La Scala</strong>, meaning a staircase or ladder in Italian, or that it derives from the famous Italian opera house <strong>Teatro alla Scala</strong>. In fact the name Scala is an abbreviation of the term SCAlable LAnguage, a fitting description of its intention. Professor Martin Odersky and his group at EPFL created the language in 2003 to provide a high-performance, concurrent-ready environment for functional programming and object-oriented programming on the Java Virtual Machine (JVM) platform.                          <br />
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#installing-scala" id="markdown-toc-installing-scala">Installing Scala</a></li>
  <li><a href="#using-the-scala-repl" id="markdown-toc-using-the-scala-repl">Using the Scala REPL</a></li>
  <li><a href="#summary" id="markdown-toc-summary">Summary</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<h2 id="installing-scala">Installing Scala</h2>

<p>As a JVM language, Scala requires the use of a Java runtime. Scala 2.11, the version you’ll be using, needs at least Java 6. However, I recommend installing the Java 8 JDK (aka Java SE for Standard Environment) instead for optimal performance. You can download the Java 8 JDK (or a later version, if available) for most platforms directly from Oracle’s website. Installers are available, so you shouldn’t need to manually configure your <code>PATH</code> variable to get the applications installed.</p>

<p>When finished, verify your Java version by running <code>java -version</code> from the command line. Here is an example of running this command for Java 8:</p>

<pre><code>$ java -version
java version "1.8.0_05"
Java(TM) SE Runtime Environment (build 1.8.0_05-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.5-b02, mixed mode)
</code></pre>

<p>Now that Java is installed, it’s time to install Scala. There are two ways to install Scala (or any other fine programming tool): the manual approach, suitable for command-line heroes who like to modify their system’s environment variables, and the automatic approach, for the rest of us.</p>

<p>To install Scala manually, download the Scala 2.11 distribution from http://www.scala-lang.org and add its “<code>bin</code>” directory to your path. The distribution includes the Scala runtimes, tools, compiled libraries, and source, but the most important item we’ll need is the scala command. This command provides (among other features) the REPL(Read-Eval-Print-Loop) shell we will use to learn and experiment with the Scala language.</p>

<p>To install Scala automatically, use a package manager such as Homebrew for OS X,Chocolatey for Windows, or apt-get/Yum for Linux systems. These are freely available and will handle finding the package, downloading and extracting it, and installing it so you can access it from the command line. The scala package is available in all of these package managers as “scala,” so you can install it with (<code>brew</code>/<code>choco</code>/<code>apt-get-yum</code>) <code>install scala</code>.</p>

<p>When installed, execute the <code>scala</code> command from the command line. You should see a welcome message like the following (although your Scala and Java version messages may be different):</p>

<pre><code>$ scala
Welcome to Scala version 2.11.0 (Java HotSpot(TM) 64-Bit Server VM,
Java 1.8.0_05).
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;
</code></pre>

<p>When you see the <code>Welcome to Scala</code> message and the <code>scala&gt;</code> prompt you are now in the Scala REPL and are ready to start coding.</p>

<p>If the command is found but there are problems launching it, make sure your Java command is installed correctly and that your system path points to the correct Java version.</p>

<h2 id="using-the-scala-repl">Using the Scala REPL</h2>

<p>If you have used other REPL shells like Python’s python, Ruby’s irb, or Groovy’s groovysh you’ll find the Scala REPL familiar. As with the REPL’s provided with the Python, Ruby,and Groovy runtimes, Scala’s REPL provides support for evaluating and executing code one line at a time with helpful feedback.</p>

<p>If you haven’t used a REPL, or are just unaccustomed to writing code outside an IDE or editor, it will take some practice to learn how to develop in the Scala REPL. However,it provides an unsurpassed way to learn and experiment quickly and responsively with the Scala language and libraries. You can enter single lines of code to evaluate and compile, and any variables you create are available for the lifetime of your session. A multiline paste mode supports entering multiple lines of code to be compiled together (instead of individually), and external source code and libraries can be loaded at any time. A help system is available and can be started by entering the <code>:help</code> command.</p>

<p>Let’s get started using the REPL by implementing the classic first exercise of all serious programming books, the “Hello World” application. Start up the REPL and make sure you see the <code>scala&gt;</code> prompt on your screen:</p>

<pre><code>scala&gt;
</code></pre>

<p>After the prompt type <code>println("Hello, World!")</code> and press <code>Return</code>. The REPL will run your <code>println()</code> command and print the output on a line below your command.Following the printout will be another <code>scala&gt;</code> prompt, waiting for a new command to run. This is the Read, Evaluate, Print, Loop behavior from which the REPL derives its name.</p>

<p>Here is how the input and response should appear in the REPL:</p>

<pre><code>scala&gt; println("Hello world!")
Hello world!

scala&gt; 
</code></pre>

<p>Congratulations, you have now written and executed Scala code.</p>

<p>The <code>println()</code> function, universally available to all Scala code, prints a message to the JVM’s stdout stream. When used in application servers that stdout stream is typically logged to a file (e.g., Tomcat’s <code>catalina.out</code>), but in the Scala REPL the <code>println()</code> function’s messages appear directly in the REPL.</p>

<p>You can use standard readline-style up-arrow and down-arrow keys to navigate to the previous and next input lines. For example, press the up-arrow key and hit Return to rerun the previous command, or press up arrow and enter a new message to print. REPL history is stored between sessions, so you can quit, run the scala command again, and press up arrow to access your previous commands.</p>

<p>Let’s try performing a simple arithmetic operation. At a new prompt type <code>5 * 7</code> and press Return. Your display should look like this:</p>

<pre><code>scala&gt; 5 * 7
res1: Int = 35

scala&gt; 
</code></pre>

<p>This time your Scala command did not print output, but instead returned a value, the product of <code>5</code> and <code>7</code>. When your commands return (or are themselves) values, the REPL will assign them to a new, constant variable so that you can refer to the value in later operations. These “<code>res</code>” variables (a shortened version of “<code>result</code>,” perhaps) are sequentially numbered so that there will always be a unique container for your command’s result.   <br />
Now that <code>res1</code> contains the output of the multiplication command, lets make use of it.Type <code>2 * res1</code> at a fresh prompt and press Return. You should see something like this:  <br />
	scala&gt; 2 * res1
	res2: Int = 70</p>

<p>As expected, the REPL recognized the <code>res1</code> variable it previously created in your arithmetic expression, and generated a new variable <code>res2</code> to store the result of the new expression.</p>

<h2 id="summary">Summary</h2>

<p>I hope you’ve seen how using the Scala REPL to evaluate and experiment with code provides an enriched learning environment for this programming language. As you continue through this book, keep the REPL open and use it to validate everything you learn. The code samples throughout the book are presented as raw captures of REPL sessions to both validate that they work and what they print out, and also to make it easier for you to replicate them in your own REPL session.  <br />
Even better, modify and rework code examples until they break. Scala is a compiled,statically typed language, so the REPL (which compiles a line after you hit Return) will let you know immediately if you have entered incorrect Scala code or not. This will help you pick up the language more quickly and better understand the limits of its syntax and features.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming Scala, 2nd Edition CHAPTER 1Zero to Sixty: Introducing Scala]]></title>
    <link href="http://scalajiaocheng.github.io/blog/2015/12/28/programming-scala-2nd-edition-chapter-1zero-to-sixty-introducing-scala/"/>
    <updated>2015-12-28T03:20:51+08:00</updated>
    <id>http://scalajiaocheng.github.io/blog/2015/12/28/programming-scala-2nd-edition-chapter-1zero-to-sixty-introducing-scala</id>
    <content type="html"><![CDATA[<p>Let’s start with a brief look at why you should give Scala a serious look. Then we’ll dive in and write some code.  <br />
<!-- more --></p>

<ul id="markdown-toc">
  <li><a href="#why-scala" id="markdown-toc-why-scala">Why Scala?</a>    <ul>
      <li><a href="#a-jvm-and-javascript-language" id="markdown-toc-a-jvm-and-javascript-language">A JVM and JavaScript language</a></li>
      <li><a href="#statically-typed" id="markdown-toc-statically-typed">Statically typed</a></li>
      <li><a href="#mixed-paradigmobject-oriented-programming" id="markdown-toc-mixed-paradigmobject-oriented-programming">Mixed paradigm—object-oriented programming</a></li>
      <li><a href="#mixed-paradigmfunctional-programming" id="markdown-toc-mixed-paradigmfunctional-programming">Mixed paradigm—functional programming</a></li>
      <li><a href="#a-sophisticated-type-system" id="markdown-toc-a-sophisticated-type-system">A sophisticated type system</a></li>
      <li><a href="#a-succinct-elegant-and-flexible-syntax" id="markdown-toc-a-succinct-elegant-and-flexible-syntax">A succinct, elegant, and flexible syntax</a></li>
      <li><a href="#scalablearchitectures" id="markdown-toc-scalablearchitectures">Scalable—architectures</a></li>
    </ul>
  </li>
  <li><a href="#the-seductions-of-scala" id="markdown-toc-the-seductions-of-scala">The Seductions of Scala</a></li>
  <li><a href="#what-about-java-8" id="markdown-toc-what-about-java-8">What About Java 8?</a></li>
  <li><a href="#installing-scala" id="markdown-toc-installing-scala">Installing Scala</a>    <ul>
      <li><a href="#here-are-the-steps" id="markdown-toc-here-are-the-steps">Here are the steps:</a>        <ul>
          <li><a href="#install-java" id="markdown-toc-install-java">Install Java</a></li>
          <li><a href="#install-sbt" id="markdown-toc-install-sbt">Install SBT</a></li>
          <li><a href="#get-the-books-code-examples" id="markdown-toc-get-the-books-code-examples">Get the book’s code examples</a></li>
          <li><a href="#start-sbt" id="markdown-toc-start-sbt">Start SBT</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#using-sbt" id="markdown-toc-using-sbt">Using SBT</a></li>
</ul>
<div class="group"></div>

<div class="center_wrapper">
  <div></div>
  <div>
    

  </div>
</div>

<h2 id="why-scala">Why Scala?</h2>

<p>Scala is a language that addresses the needs of the modern software developer. It is a statically typed, mixed-paradigm, JVM language with a succinct(简洁的；简明的；紧身的), elegant, and flexible syntax, a sophisticated(复杂的) type system, and idioms that promote scalability from small,interpreted scripts to large, sophisticated applications. That’s a mouthful, so let’s look at each of those ideas in more detail:</p>

<h3 id="a-jvm-and-javascript-language">A JVM and JavaScript language</h3>

<p>Scala exploits(利用) the performance and optimizations(最佳化) of the JVM, as well as the rich ecosystem of tools and libraries built around Java. But it’s not limited to the JVM!Scala.js is an experimental port to JavaScript.</p>

<h3 id="statically-typed">Statically typed</h3>

<p>Scala embraces(拥抱) static typing as a tool for creating robust applications. It fixes many of the flaws of Java’s type system and it uses type inference to eliminate much of the typing boilerplate.</p>

<h3 id="mixed-paradigmobject-oriented-programming">Mixed paradigm—object-oriented programming</h3>

<p>Scala fully supports object-oriented programming (OOP). Scala improves Java’s object model with the addition of traits, a clean way of implementing types using mixin composition. In Scala, everything really is an object, even numeric types.</p>

<h3 id="mixed-paradigmfunctional-programming">Mixed paradigm—functional programming</h3>

<p>Scala fully supports functional programming (FP). FP has emerged as the best tool for thinking about problems of concurrency, Big Data, and general code correctness. Immutable values, first-class functions, functions without side effects,“higher-order” functions, and function collections all contribute to concise, powerful, correct code.</p>

<h3 id="a-sophisticated-type-system">A sophisticated type system</h3>

<p>Scala extends the type system of Java with more flexible generics and other enhancements to improve code correctness. With type inference, Scala code is often as concise as code in dynamically typed languages.</p>

<h3 id="a-succinct-elegant-and-flexible-syntax">A succinct, elegant, and flexible syntax</h3>

<p>Verbose expressions in Java become concise idioms in Scala. Scala provides several facilities for building domain-specific languages (DSLs), APIs that feel “native” to users.</p>

<h3 id="scalablearchitectures">Scalable—architectures</h3>

<p>You can write small, interpreted scripts to large, distributed applications in Scala.Four language mechanisms promote scalable composition of systems: 1) mixin composition using traits; 2) abstract type members and generics; 3) nested classes; and 4) explicit self types.</p>

<p>The name Scala is a contraction(缩写) of the words scalable language. It is pronounced scahlah, like the Italian word for “staircase.” Hence, the two “a”s are pronounced the same. <br />
Scala was started by Martin Odersky in 2001. The first public release was January 20th,2004 (see http://bit.ly/1toEmFE). Martin is a professor in the School of Computer and Communication Sciences at the Ecole Polytechnique Fédérale de Lausanne (EPFL). He spent his graduate years working in the group headed by Niklaus Wirth, of Pascal fame.Martin worked on Pizza, an early functional language on the JVM. He later worked on GJ, a prototype of what later became Generics in Java, along with Philip Wadler, one of the designers of Haskell. Martin was hired by Sun Microsystems to produce the reference implementation of javac, the descendant of which is the Java compiler that ships with the Java Developer Kit (JDK) today.</p>

<h2 id="the-seductions-of-scala">The Seductions of Scala</h2>

<p>The rapid growth of Scala users since the first edition of this book confirms my view that Scala is a language for our time. You can leverage the maturity(成熟) of the JVM, libraries,and production tools, while enjoying state-of-the-art language features with a concise,yet expressive syntax for addressing today’s challenges, such as Big Data, scaling through concurrency, and providing highly available and robust services.                    <br />
In any field of endeavor, the professionals need sophisticated, powerful tools and techniques. It may take a while to master them, but you make the effort because mastery is the key to your success.                 <br />
I believe Scala is a language for professional developers. Not all users are professionals,of course, but Scala is the kind of language a professional in our field needs, rich in features, highly performant, expressive for a wide class of problems. It will take you a while to master Scala, but once you do, you won’t feel constrained by your programming language.</p>

<h2 id="what-about-java-8">What About Java 8?</h2>

<p>Java 8 is the most significant update to Java since Java 5 introduced generics. Now we have real anonymous functions, called lambdas. You’ll see why they are so useful in this book. Interfaces have been extended to allow “default” implementations of the methods they declare, making them more usable as composable mixins, like Scala’s traits. These features are arguably the two most valuable improvements that Scala brought to the JVM compared to Java before version 8. So, is there any point in switching?</p>

<p>Scala adds many improvements that Java may never have, due to backward compatibility limitations, or Java may eventually have them but not until years from now. For example,Scala has richer type inference than Java can provide. Scala has powerful pattern matching and for comprehensions that dramatically reduce code size and coupling between types. You’ll see why they are so valuable as we go.</p>

<p>Also, many organizations are understandably cautious about upgrading their JVM in‐frastructure. For them deploying the Java 8 JVM may not be an option for a while. At least those organizations can use Scala now with the Java 6 and 7 JVMs.    <br />
Still, if you can use Java 8 you might decide it’s the best path forward for your team.Reading this book will still teach you many useful techniques that you can apply to Java 8 applications. However, I suspect you’ll still find all the additional features of Scala worth the switch.  <br />
Okay, let’s get started.</p>

<h2 id="installing-scala">Installing Scala</h2>

<p>To get up and running as quickly as possible, this section describes how to install some command-line tools that are all you need to work with the examples in the book.The examples used in this book were written and compiled using Scala version 2.11.2, the latest release at the time of this writing. Most also work unmodified with the previous release, Scala version 2.10.4, because many teams are still using that version.  <br />
Scala 2.11 introduced some new features compared to 2.10, but the release mostly focused on general performance improvements and library refactoring. Scala 2.10 introduced a number of new features compared to 2.9. Because your organization may be using any of these versions, we’ll discuss the most important differences as we go.</p>

<h3 id="here-are-the-steps">Here are the steps:</h3>

<h4 id="install-java">Install Java</h4>

<p>Until Scala 2.12 comes along, Java 6, 7, or 8 can be used and it must be installed on your computer (Scala 2.12, which is planned for early 2016, will support Java 8 only). If you need to install Java, go to the Oracle website and follow the instructions to install the full Java Development Kit (JDK).</p>

<h4 id="install-sbt">Install SBT</h4>

<p>Install the de facto build tool for Scala, SBT by following the instructions at scalasbt.org. When you are finished, you will have an sbt command that you can run from a Linux or OS X terminal or Windows command window. (Other build tools can be used, as we’ll see in “Other Build Tools” on page 484.)</p>

<h4 id="get-the-books-code-examples">Get the book’s code examples</h4>

<p>Download the code examples as described in “Getting the Code Examples” on page xxiii. Expand the archive somewhere convenient on your computer.</p>

<h4 id="start-sbt">Start SBT</h4>

<p>Open a shell or command window and move to the directory where you expanded the code examples. Type the command <code>sbt test</code>, which will download all the dependencies you need, including the Scala compiler and third-party libraries. This will take a while and you’ll need an Internet connection. Then <code>sbt</code> will compile the code and run the unit tests. You’ll see lots of output, ending with a “success” message.If you run the command again, it should finish very quickly because it won’t need to do anything again.</p>

<p>Congratulations! You’re ready to get started. However, you might want to install a few more things that are useful.</p>

<p>For most of the book, we’ll use these tools indirectly through SBT,which downloads the Scala compiler version we want, the standard library, and the required third-party dependencies automatically.</p>

<p>It’s handy to download the Scala tools separately, for those times when you aren’t working in SBT. We’ll run a few of our examples using Scala outside SBT.</p>

<p>Follow the links on the official Scala website to install Scala and optionally, the Scala‐docs, the analog of Javadocs for Scala (in Scala 2.11, the Scala library and Scaladocs have been split into several, smaller libraries). You can also read the Scaladocs online. For your convenience, most mentions of a type in the Scala library will be a link corresponding to a Scaladocs page.</p>

<p>A handy feature of the Scaladocs is a search field above the list of types on the lefthand side. It is very handy for finding a type quickly. Also, the entry for each type has a link to view the corresponding source code in Scala’s GitHub repository, which is a good way to learn how the library was implemented. Look for the link on the line labeled “Source.” It will be near the bottom of the overview discussion for the type.</p>

<p>Any text editor or IDE (integrated development environment) will suffice for working with the examples. You can find Scala support plug-ins for all the major editors and IDEs. For more details, see “Integration with IDEs and Text Editors” on page 485. In general, the community for your favorite editor is your best source of up-to-the-minute information on Scala support.</p>

<h2 id="using-sbt">Using SBT</h2>

<p>We’ll learn how SBT works in “SBT, the Standard Build Tool for Scala” on page 482. For now, let’s cover the basics we need to get started.</p>

<p>When you start the <code>sbt</code> command, if you don’t specify a task to run, SBT starts an interactive REPL (Read, Eval, Print, Loop). Let’s try that now and see a few of the available “tasks.” <br />
In the listing that follows, the <code>$</code> is the shell command prompt (e.g., bash), where you start the <code>sbt</code> command, the <code>&gt;</code> is the default SBT interactive prompt, and the <code>#</code> starts an <code>sbt</code> comment. You can type most of these commands in any order:</p>

]]></content>
  </entry>
  
</feed>
